{
    "comments": [
        {
            "tags": [],
            "description": {
                "full": "<p>Functions \"each\", \"extend\", and \"isFunction\" based on Underscore.js 1.5.2<br />  <a href='http://underscorejs.org'>http://underscorejs.org</a><br />  (c) 2009-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters &amp; Editors<br />  Underscore may be freely distributed under the MIT license.</p>",
                "summary": "<p>Functions \"each\", \"extend\", and \"isFunction\" based on Underscore.js 1.5.2<br />  <a href='http://underscorejs.org'>http://underscorejs.org</a><br />  (c) 2009-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters &amp; Editors<br />  Underscore may be freely distributed under the MIT license.</p>",
                "body": ""
            },
            "ignore": true,
            "code": "(function() {",
            "fileName": "../src/base.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>global d3: false<br />global d4: false</p>",
                "summary": "<p>global d3: false<br />global d4: false</p>",
                "body": ""
            },
            "ignore": true,
            "code": "'use strict';\n\n  var root = this;\n  var breaker = {};\n\n  // Create a safe reference to the d4 object.\n  var d4 = function(obj) {\n    if (obj instanceof d4) {\n      return obj;\n    }\n    if (!(this instanceof d4)) {\n      return new d4(obj);\n    }\n    this.d4Wrapped = obj;\n  };\n\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = d4;\n    }\n    exports.d4 = d4;\n  } else {\n    root.d4 = d4;\n  }\n\n  d4.charts = {};\n  d4.features = {};\n  d4.parsers = {};\n  d4.builders = {};\n\n  var each = d4.each = d4.forEach = function(obj, iterator, context) {\n    var nativeForEach = Array.prototype.forEach,\n      i, len;\n    if (obj === null) {\n      return;\n    }\n\n    if (nativeForEach && obj.forEach === nativeForEach) {\n      obj.forEach(iterator, context);\n    } else if (obj.length === +obj.length) {\n      for (i = 0, len = obj.length; i < len; i++) {\n        if (iterator.call(context, obj[i], i, obj) === breaker) {\n          return;\n        }\n      }\n    } else {\n      var keys = d3.keys(obj);\n      for (i = 0, len = keys.length; i < len; i++) {\n        if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker) {\n          return;\n        }\n      }\n    }\n  };\n\n  var readOnlyProp = function(obj, prop, functName, value){\n    Object.defineProperty(obj, prop, {\n      configurable: true,\n      get: function(){\n        return d4.functor(value)();\n      },\n      set: function() {\n        err(' You cannot directly assign values to the {0} property. Instead use the {1}() function.', prop, functName);\n      }\n    });\n  };\n\n  var err = function() {\n    var parts = Array.prototype.slice.call(arguments);\n    var message = parts.shift();\n    var regexp;\n    each(parts, function(str, i){\n      regexp = new RegExp('\\\\{' + i + '\\\\}', 'gi');\n      message = message.replace(regexp, str);\n    });\n    throw new Error('[d4] ' + message);\n  };\n\n  var validateBuilder = function(builder) {\n    each(['link'], function(funct) {\n      if (!builder[funct] || d4.isNotFunction(builder[funct])) {\n        err('The supplied builder does not have a {0} function', funct);\n      }\n    });\n    return builder;\n  };\n\n  var assignDefaultBuilder = function(defaultBuilder) {\n    if (!this.builder) {\n      this.builder = validateBuilder(defaultBuilder.bind(this)());\n    }\n    return this;\n  };",
            "fileName": "../src/base.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>In an effort to make the API more succient we store the last known proplerty<br />  of an accessor with the same name but prepended with a $ character. This allows<br />  the developer to do something like this:<br />      chart.width(500)<br />      chart.$width //500</p>",
                "summary": "<p>In an effort to make the API more succient we store the last known proplerty<br />  of an accessor with the same name but prepended with a $ character. This allows<br />  the developer to do something like this:<br />      chart.width(500)<br />      chart.$width //500</p>",
                "body": ""
            },
            "ignore": true,
            "code": "var storeLastValue = function(obj, functName, attr) {\n    if(d4.isNotFunction(attr)){\n      var prop = '$' + functName;\n      readOnlyProp(obj, prop, functName, attr);\n    }\n  };",
            "ctx": {
                "type": "function",
                "name": "storeLastValue",
                "string": "storeLastValue()"
            },
            "fileName": "../src/base.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>FIXME: d4 wraps the inner property object <code>opts</code> in a series of class<br />  functions. For example: <code>chart.width(300)</code> will set the internal<br />  <code>opts.width</code> property to 300. Additionally chart.width() will return 300.<br />  However, this behavior creates ambiguity in API because it is unclear to the<br />  developer which accessors require functions and which can simply supply<br />  values. Ideally the API should support something like this:<br />  chart.width(300) or chart.width(function(){ return 300; })</p>",
                "summary": "<p>FIXME: d4 wraps the inner property object <code>opts</code> in a series of class<br />  functions. For example: <code>chart.width(300)</code> will set the internal<br />  <code>opts.width</code> property to 300. Additionally chart.width() will return 300.<br />  However, this behavior creates ambiguity in API because it is unclear to the<br />  developer which accessors require functions and which can simply supply<br />  values. Ideally the API should support something like this:<br />  chart.width(300) or chart.width(function(){ return 300; })</p>",
                "body": ""
            },
            "ignore": true,
            "code": "var accessorForObject = function(wrapperObj, innerObj, functName) {\n    wrapperObj[functName] = function(attr) {\n      if (!arguments.length) {\n        return innerObj[functName];\n      }\n      storeLastValue(wrapperObj, functName, attr);\n      innerObj[functName] = attr;\n      return wrapperObj;\n    };\n    storeLastValue(wrapperObj, functName, innerObj[functName]);\n  };\n\n  var createAccessorsFromArray = function(wrapperObj, innerObj, accessors){\n    each(accessors, function(functName) {\n      accessorForObject(wrapperObj, innerObj, functName);\n    });\n  };",
            "ctx": {
                "type": "function",
                "name": "accessorForObject",
                "string": "accessorForObject()"
            },
            "fileName": "../src/base.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>In order to have a uniform API, objects with accessors, need to have wrapper<br />functions created for them so that users may access them in the declarative<br />nature we promote. This function will take an object, which contains an<br />accessors key and create the wrapper function for each accessor item.<br />This function is used internally by the feature mixin and axes objects.</p>",
                "summary": "<p>In order to have a uniform API, objects with accessors, need to have wrapper<br />functions created for them so that users may access them in the declarative<br />nature we promote. This function will take an object, which contains an<br />accessors key and create the wrapper function for each accessor item.<br />This function is used internally by the feature mixin and axes objects.</p>",
                "body": ""
            },
            "ignore": true,
            "code": "var createAccessorsFromObject = function(obj){\n    var accessors = obj.accessors;\n    if (accessors) {\n      createAccessorsFromArray(obj, obj.accessors, d3.keys(accessors));\n    }\n  };\n\n  var createAccessorsFromAxes = function(chart, opts) {\n    each(d3.keys(opts.axes), function(key) {\n      chart[key] = function(funct) {\n        usingAxis.bind(opts)(key, funct);\n        return chart;\n      };\n      each(d3.keys(opts.axes[key].accessors), function(prop){\n        chart[key][prop] = opts.axes[key][prop];\n      });\n    });\n  };\n\n  var validateScale = function(kind){\n    var supportedScales = d3.keys(d3.scale);\n    if(supportedScales.indexOf(kind) < 0){\n      err('The scale type: \"{0}\" is unrecognized. D4 only supports these scale types: {1}', kind, supportedScales.join(', '));\n    }\n  };",
            "ctx": {
                "type": "function",
                "name": "createAccessorsFromObject",
                "string": "createAccessorsFromObject()"
            },
            "fileName": "../src/base.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>Unlike the other axis accessors the <code>scale()</code> is special because each d3 scale<br />will have its own collection of functions, which may differ from one another<br />Therefore, when setting the scale to something say from linear to ordinal<br />we need to actually tell d4 to recreate the scale again otherwise the user<br />may try to use scale specific methods that no longer apply, and will create<br />an error down the road.</p>",
                "summary": "<p>Unlike the other axis accessors the <code>scale()</code> is special because each d3 scale<br />will have its own collection of functions, which may differ from one another<br />Therefore, when setting the scale to something say from linear to ordinal<br />we need to actually tell d4 to recreate the scale again otherwise the user<br />may try to use scale specific methods that no longer apply, and will create<br />an error down the road.</p>",
                "body": ""
            },
            "ignore": true,
            "code": "var createAxisScaleAccessor = function(scale, dimension, resetFunct) {\n\n    // Create a transparent proxy for functions needed by the d3 scale.\n    createAccessorsFromArray(dimension, scale, d3.keys(scale));\n\n    dimension.scale = function(val){\n      if (!arguments.length) {\n        return dimension.accessors.scale;\n      }\n      dimension.accessors.scale = val;\n      resetFunct();\n      return dimension;\n    };\n  };\n\n  var createAxisScale = function(dimension, opts, axis){\n    validateScale(axis.accessors.scale);\n    var scale = d3.scale[axis.accessors.scale]();\n    createAccessorsFromObject(axis);\n    opts[dimension] = scale;\n\n    createAxisScaleAccessor(scale, opts.axes[dimension], function(){\n      createAxisScale(dimension, opts, axis);\n    });\n\n    // Danger Zone (TM): This is setting read-only function properties on a d3 scale instance. This may not be totally wise.\n    each(d3.keys(opts.axes[dimension].accessors), function(key){\n      readOnlyProp(opts[dimension], '$' + key, opts.axes[dimension][key], opts.axes[dimension][key]);\n    });\n  };\n\n  var addAxis = function(dimension, opts, axis){\n    opts.axes[dimension] = {\n      accessors : d4.extend({\n        key : dimension,\n        min : undefined,\n        max : undefined\n      }, axis)\n    };\n    createAxisScale(dimension, opts, opts.axes[dimension]);\n  };\n\n  var linkAxes = function(opts) {\n    each(d3.keys(opts.axes), function(dimension){\n      addAxis(dimension, opts, opts.axes[dimension]);\n    });\n\n    if(typeof(opts.axes.x) === 'undefined') {\n      addAxis('x', opts, { scale : 'ordinal' });\n    }\n\n    if(typeof(opts.axes.y) === 'undefined') {\n      addAxis('y', opts, { scale : 'linear' });\n    }\n  };\n\n  var assignDefaults = function(config, defaultBuilder) {\n    if (!defaultBuilder) {\n      err('No builder defined');\n    }\n    var opts = d4.merge({\n      width: 400,\n      height: 400,\n      features: {},\n      mixins: [],\n      axes: {},\n      valueKey: 'y',\n      margin: {\n        top: 20,\n        right: 20,\n        bottom: 20,\n        left: 40\n      }\n    }, config);\n    linkAxes(opts);\n    assignDefaultBuilder.bind(opts)(defaultBuilder);\n    opts.accessors = ['margin', 'width', 'height', 'valueKey'].concat(config.accessors || []);\n    return opts;\n  };",
            "ctx": {
                "type": "function",
                "name": "createAxisScaleAccessor",
                "string": "createAxisScaleAccessor()"
            },
            "fileName": "../src/base.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>d3 allows events to be bound to selections using the <code>#on()</code> function. We<br />    want to allow the developer to bind to these events transparently. However,<br />    we are not actually dealing with the d3 selection itself and so we need to<br />    create this proxy which passes any custom events on to the correct selection.<br />    For more information see the #selection.on documentation for d3:<br />    <a href='https://github.com/mbostock/d3/wiki/Selections#wiki-animation--interaction'>https://github.com/mbostock/d3/wiki/Selections#wiki-animation--interaction</a></p>",
                "summary": "<p>d3 allows events to be bound to selections using the <code>#on()</code> function. We<br />    want to allow the developer to bind to these events transparently. However,<br />    we are not actually dealing with the d3 selection itself and so we need to<br />    create this proxy which passes any custom events on to the correct selection.<br />    For more information see the #selection.on documentation for d3:<br />    <a href='https://github.com/mbostock/d3/wiki/Selections#wiki-animation--interaction'>https://github.com/mbostock/d3/wiki/Selections#wiki-animation--interaction</a></p>",
                "body": ""
            },
            "ignore": true,
            "code": "var addEventsProxy = function(feature, selection){\n    if(selection){\n      each(d3.keys(feature._proxiedFunctions), function(key){\n        each(feature._proxiedFunctions[key], function(proxiedArgs){\n          selection[key].apply(selection, proxiedArgs);\n        });\n      });\n    }\n  };\n\n  var linkFeatures = function(opts, data) {\n    opts.mixins.forEach(function(name) {\n      var selection = opts.features[name].render.bind(opts)(opts.features[name], data);\n      addEventsProxy(opts.features[name], selection);\n    });\n  };\n\n  var build = function(opts, data) {\n    if (opts.builder) {\n      opts.builder.link(opts, data);\n      linkFeatures(opts, data);\n    } else {\n      err('No builder defined');\n    }\n  };\n\n  var scaffoldChart = function(selection, data) {\n    this.svg = d3.select(selection).selectAll('svg').data([data]);\n    this.featuresGroup = this.svg.enter().append('svg').append('g')\n      .attr('class', 'featuresGroup')\n      .attr('transform', 'translate(' + this.margin.left + ',' + this.margin.top + ')');\n    this.svg.attr('width', this.width).attr('height', this.height).attr('class', 'd4');\n    this.svg.append('defs');\n  };",
            "ctx": {
                "type": "function",
                "name": "addEventsProxy",
                "string": "addEventsProxy()"
            },
            "fileName": "../src/base.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>Normally d4 series elements inside the data array to be in a specific<br />  format, which is designed to support charts which require multiple data<br />  series. However, some charts can easily be used to display only a single data<br />  series in which case the default structure is overly verbose. In these cases<br />  d4 accepts the simplified objects in the array payload and silently<br />  parses them using the d4.nestedGroup parser. It will configure the parser's<br />  dimensions based on the configuration applied to the chart object itself.</p>",
                "summary": "<p>Normally d4 series elements inside the data array to be in a specific<br />  format, which is designed to support charts which require multiple data<br />  series. However, some charts can easily be used to display only a single data<br />  series in which case the default structure is overly verbose. In these cases<br />  d4 accepts the simplified objects in the array payload and silently<br />  parses them using the d4.nestedGroup parser. It will configure the parser's<br />  dimensions based on the configuration applied to the chart object itself.</p>",
                "body": ""
            },
            "ignore": true,
            "code": "var applyDefaultParser = function(opts, data) {\n    if(opts.y.$key !== opts.valueKey){\n      opts.valueKey = opts.y.$key;\n    }\n    var parsed = d4.parsers.nestedGroup()\n    .x(opts.x.$key)\n    .y(opts.y.$key)\n    .nestKey(opts.x.$key)\n    .value(opts.valueKey)(data);\n    return parsed.data;\n  };\n\n  var prepareData = function(opts, data) {\n    var needsParsing = false, keys, item;\n    if(data.length > 0){\n      item = data[0];\n      if(d4.isArray(item)) {\n        needsParsing = true;\n      } else {\n        keys = d3.keys(item);\n        if(keys.indexOf('key') + keys.indexOf('values') <= 0) {\n          needsParsing = true;\n        }\n      }\n    }\n    return needsParsing ? applyDefaultParser(opts, data) : data;\n  };\n\n  var applyScaffold = function(opts) {\n    return function(selection) {\n      selection.each(function(data) {\n        data = prepareData(opts, data);\n        scaffoldChart.bind(opts, this)(data);\n        build(opts, data);\n      });\n    };\n  };\n\n  var extractOverrides = function(feature) {\n    if (feature.overrides) {\n      return feature.overrides(this);\n    } else {\n      return {};\n    }\n  };\n\n  var addToMixins = function(mixins, name, index){\n    if (typeof index !== 'undefined') {\n      index = Math.max(Math.min(index, mixins.length), 0);\n      mixins.splice(index, 0, name);\n    } else {\n      mixins.push(name);\n    }\n  };\n\n  var assignD3SelectionProxy = function(feature){\n    feature._proxiedFunctions = {\n      on : []\n    };\n    feature.on = function(){\n      feature._proxiedFunctions.on.push(Array.prototype.slice.call(arguments));\n    };\n  };\n\n  var assignMixinAccessors = function(feature){\n    assignD3SelectionProxy(feature);\n    createAccessorsFromObject(feature);\n  };\n\n  var mixin = function(feature, index) {\n    if (!feature) {\n      err('You need to supply an object to mixin.');\n    }\n    var name = d3.keys(feature)[0];\n    var overrides = extractOverrides.bind(this)(feature, name);\n    feature[name] = d4.merge(feature[name](name), overrides);\n    d4.extend(this.features, feature);\n    addToMixins(this.mixins, name, index);\n    assignMixinAccessors(this.features[name]);\n  };\n\n  var mixout = function(name) {\n    if (!name) {\n      err('A name is required in order to mixout a chart feature.');\n    }\n\n    delete this.features[name];\n    this.mixins = this.mixins.filter(function(val) {\n      return val !== name;\n    });\n  };\n\n  var usingFeature = function(name, funct) {\n    var feature = this.features[name];\n    if (d4.isNotFunction(funct)) {\n      err('You must supply a continuation function in order to use a chart feature.');\n    }\n    if (!feature) {\n      err('Could not find feature: \"{0}\", maybe you forgot to mix it in?', name);\n    } else {\n      funct.bind(this)(feature);\n    }\n  };\n\n  var usingAxis = function(key, funct) {\n    var axis = this.axes[key];\n    if (d4.isNotFunction(funct)) {\n      err('You must supply a continuation function in order to use a chart axis.');\n    }\n    if (!axis) {\n      err('Could not find axis: \"{0}\", maybe you forgot to define it?', key);\n    } else {\n      funct.bind(this)(axis);\n    }\n  };",
            "ctx": {
                "type": "function",
                "name": "applyDefaultParser",
                "string": "applyDefaultParser()"
            },
            "fileName": "../src/base.js"
        },
        {
            "tags": [
                {
                    "type": "param",
                    "types": [
                        "String"
                    ],
                    "name": "name",
                    "description": "- accessor name for chart."
                },
                {
                    "type": "param",
                    "types": [
                        "Function"
                    ],
                    "name": "funct",
                    "description": "- function which will instantiate the chart."
                },
                {
                    "type": "returns",
                    "string": "a reference to the chart function"
                }
            ],
            "description": {
                "full": "<p>This function allows you to register a reusable chart with d4.</p>",
                "summary": "<p>This function allows you to register a reusable chart with d4.</p>",
                "body": ""
            },
            "isPrivate": false,
            "ignore": false,
            "code": "d4.chart = function(name, funct) {\n    d4.charts[name] = funct;\n    return d4.charts[name];\n  };",
            "ctx": {
                "type": "method",
                "receiver": "d4",
                "name": "chart",
                "string": "d4.chart()"
            },
            "fileName": "../src/base.js"
        },
        {
            "tags": [
                {
                    "type": "param",
                    "types": [
                        "String"
                    ],
                    "name": "name",
                    "description": "- accessor name for chart feature."
                },
                {
                    "type": "param",
                    "types": [
                        "Function"
                    ],
                    "name": "funct",
                    "description": "- function which will instantiate the chart feature."
                },
                {
                    "type": "returns",
                    "string": "a reference to the chart feature"
                }
            ],
            "description": {
                "full": "<p>This function allows you to register a reusable chart feature with d4.</p>",
                "summary": "<p>This function allows you to register a reusable chart feature with d4.</p>",
                "body": ""
            },
            "isPrivate": false,
            "ignore": false,
            "code": "d4.feature = function(name, funct) {\n    d4.features[name] = funct;\n    return d4.features[name];\n  };",
            "ctx": {
                "type": "method",
                "receiver": "d4",
                "name": "feature",
                "string": "d4.feature()"
            },
            "fileName": "../src/base.js"
        },
        {
            "tags": [
                {
                    "type": "param",
                    "types": [
                        "String"
                    ],
                    "name": "name",
                    "description": "- accessor name for chart builder."
                },
                {
                    "type": "param",
                    "types": [
                        "Function"
                    ],
                    "name": "funct",
                    "description": "- function which will instantiate the chart builder."
                },
                {
                    "type": "returns",
                    "string": "a reference to the chart builder"
                }
            ],
            "description": {
                "full": "<p>This function allows you to register a reusable chart builder with d4.</p>",
                "summary": "<p>This function allows you to register a reusable chart builder with d4.</p>",
                "body": ""
            },
            "isPrivate": false,
            "ignore": false,
            "code": "d4.builder = function(name, funct) {\n    d4.builders[name] = funct;\n    return d4.builders[name];\n  };",
            "ctx": {
                "type": "method",
                "receiver": "d4",
                "name": "builder",
                "string": "d4.builder()"
            },
            "fileName": "../src/base.js"
        },
        {
            "tags": [
                {
                    "type": "param",
                    "types": [
                        "String"
                    ],
                    "name": "name",
                    "description": "- accessor name for data parser."
                },
                {
                    "type": "param",
                    "types": [
                        "Function"
                    ],
                    "name": "funct",
                    "description": "- function which will instantiate the data parser."
                },
                {
                    "type": "returns",
                    "string": "a reference to the data parser"
                }
            ],
            "description": {
                "full": "<p>This function allows you to register a reusable data parser with d4.</p>",
                "summary": "<p>This function allows you to register a reusable data parser with d4.</p>",
                "body": ""
            },
            "isPrivate": false,
            "ignore": false,
            "code": "d4.parser = function(name, funct) {\n    d4.parsers[name] = funct;\n    return d4.parsers[name];\n  };",
            "ctx": {
                "type": "method",
                "receiver": "d4",
                "name": "parser",
                "string": "d4.parser()"
            },
            "fileName": "../src/base.js"
        },
        {
            "tags": [
                {
                    "type": "param",
                    "types": [
                        "Function"
                    ],
                    "name": "defaultBuilder",
                    "description": "- function which will return a valid builder object when invoked."
                },
                {
                    "type": "param",
                    "types": [
                        "Object"
                    ],
                    "name": "config",
                    "description": "- an object representing chart configuration settings"
                },
                {
                    "type": "returns",
                    "string": "a reference to the chart object"
                }
            ],
            "description": {
                "full": "<p>This function creates a d4 chart object. It is only used when creating a<br />new chart factory.</p>\n\n<h5>Examples</h5>\n\n<pre><code>d4.chart('column', function columnChart() {\n    var chart = d4.baseChart({\n      axes: [{\n        key: 'x',\n        scale: 'ordinal'\n      }, {\n        key: 'y',\n        scale: 'linear'\n      }]\n    }, columnChartBuilder);\n    return chart;\n});\n</code></pre>",
                "summary": "<p>This function creates a d4 chart object. It is only used when creating a<br />new chart factory.</p>",
                "body": "<h5>Examples</h5>\n\n<pre><code>d4.chart('column', function columnChart() {\n    var chart = d4.baseChart({\n      axes: [{\n        key: 'x',\n        scale: 'ordinal'\n      }, {\n        key: 'y',\n        scale: 'linear'\n      }]\n    }, columnChartBuilder);\n    return chart;\n});\n</code></pre>"
            },
            "isPrivate": false,
            "ignore": false,
            "code": "d4.baseChart = function(defaultBuilder, config) {\n    var opts = assignDefaults(config || {}, defaultBuilder);\n    var chart = applyScaffold(opts);\n\n    chart.accessors = opts.accessors;\n    createAccessorsFromArray(chart, opts, chart.accessors);\n    createAccessorsFromAxes(chart, opts);",
            "ctx": {
                "type": "method",
                "receiver": "d4",
                "name": "baseChart",
                "string": "d4.baseChart()"
            },
            "fileName": "../src/base.js"
        },
        {
            "tags": [
                {
                    "type": "param",
                    "types": [
                        "Function"
                    ],
                    "name": "funct",
                    "description": "- function which returns a builder object."
                }
            ],
            "description": {
                "full": "<p>Specifies an object, which d4 uses to initialize the chart with. By default<br />d4 expects charts to return a builder object, which will be used to<br />configure defaults for the chart. Typically this means determining the<br />the default value for the various axes. This accessor allows you to<br />override the existing builder provided by a chart and use your own.</p>\n\n<h5>Examples</h5>\n\n<pre><code>myChart.builder = function(chart, data){\n    return {\n       link: function(chart, data) {\n           configureScales.bind(this)(chart, data);\n       }\n    };\n};\n</code></pre>",
                "summary": "<p>Specifies an object, which d4 uses to initialize the chart with. By default<br />d4 expects charts to return a builder object, which will be used to<br />configure defaults for the chart. Typically this means determining the<br />the default value for the various axes. This accessor allows you to<br />override the existing builder provided by a chart and use your own.</p>",
                "body": "<h5>Examples</h5>\n\n<pre><code>myChart.builder = function(chart, data){\n    return {\n       link: function(chart, data) {\n           configureScales.bind(this)(chart, data);\n       }\n    };\n};\n</code></pre>"
            },
            "isPrivate": false,
            "ignore": false,
            "code": "chart.builder = function(funct) {\n      validateBuilder(funct.bind(chart)(opts));\n      return chart;\n    };",
            "ctx": {
                "type": "method",
                "receiver": "chart",
                "name": "builder",
                "string": "chart.builder()"
            },
            "fileName": "../src/base.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>To see what features are currently mixed into your chart you can use<br />this method. This function cannot be chained.</p>\n\n<h5>Examples</h5>\n\n<pre><code> // Mixout the yAxis which is provided as a default\n var chart = d4.charts.column()\n .mixout('yAxis');\n\n // Now test that the feature has been removed.\n console.log(chart.features());\n =&gt; [\"bars\", \"barLabels\", \"xAxis\"]\n</code></pre>",
                "summary": "<p>To see what features are currently mixed into your chart you can use<br />this method. This function cannot be chained.</p>",
                "body": "<h5>Examples</h5>\n\n<pre><code> // Mixout the yAxis which is provided as a default\n var chart = d4.charts.column()\n .mixout('yAxis');\n\n // Now test that the feature has been removed.\n console.log(chart.features());\n =&gt; [\"bars\", \"barLabels\", \"xAxis\"]\n</code></pre>"
            },
            "ignore": false,
            "code": "chart.features = function() {\n      return opts.mixins;\n    };",
            "ctx": {
                "type": "method",
                "receiver": "chart",
                "name": "features",
                "string": "chart.features()"
            },
            "fileName": "../src/base.js"
        },
        {
            "tags": [
                {
                    "type": "param",
                    "types": [
                        "Object"
                    ],
                    "name": "feature",
                    "description": "- an object describing the feature to mix in."
                },
                {
                    "type": "param",
                    "types": [
                        "Integer"
                    ],
                    "name": "index",
                    "description": "- an optional number to specify the insertion layer."
                }
            ],
            "description": {
                "full": "<p>Specifies a feature to be mixed into a given chart.<br />The feature is an object where the key represents the feature name, and a<br />value which is a function that when invoked returns a d4 feature object.</p>\n\n<h5>Examples</h5>\n\n<pre><code> // Mix in a feature at a specific depth\n chart.mixin({ 'grid': d4.features.grid }, 0)\n\n chart.mixin({ 'zeroLine': d4.features.referenceLine })\n</code></pre>",
                "summary": "<p>Specifies a feature to be mixed into a given chart.<br />The feature is an object where the key represents the feature name, and a<br />value which is a function that when invoked returns a d4 feature object.</p>",
                "body": "<h5>Examples</h5>\n\n<pre><code> // Mix in a feature at a specific depth\n chart.mixin({ 'grid': d4.features.grid }, 0)\n\n chart.mixin({ 'zeroLine': d4.features.referenceLine })\n</code></pre>"
            },
            "isPrivate": false,
            "ignore": false,
            "code": "chart.mixin = function(feature, index) {\n      mixin.bind(opts)(feature, index);\n      return chart;\n    };",
            "ctx": {
                "type": "method",
                "receiver": "chart",
                "name": "mixin",
                "string": "chart.mixin()"
            },
            "fileName": "../src/base.js"
        },
        {
            "tags": [
                {
                    "type": "param",
                    "types": [
                        "String"
                    ],
                    "name": "name",
                    "description": "- accessor name for chart feature."
                }
            ],
            "description": {
                "full": "<p>Specifies an existing feature of a chart to be removed (mixed out).</p>\n\n<h5>Examples</h5>\n\n<pre><code> // Mixout the yAxis which is provided as a default\n var chart = d4.charts.column()\n .mixout('yAxis');\n\n // Now test that the feature has been removed.\n console.log(chart.features());\n =&gt; [\"bars\", \"barLabels\", \"xAxis\"]\n</code></pre>",
                "summary": "<p>Specifies an existing feature of a chart to be removed (mixed out).</p>",
                "body": "<h5>Examples</h5>\n\n<pre><code> // Mixout the yAxis which is provided as a default\n var chart = d4.charts.column()\n .mixout('yAxis');\n\n // Now test that the feature has been removed.\n console.log(chart.features());\n =&gt; [\"bars\", \"barLabels\", \"xAxis\"]\n</code></pre>"
            },
            "isPrivate": false,
            "ignore": false,
            "code": "chart.mixout = function(feature, index) {\n      mixout.bind(opts)(feature, index);\n      return chart;\n    };",
            "ctx": {
                "type": "method",
                "receiver": "chart",
                "name": "mixout",
                "string": "chart.mixout()"
            },
            "fileName": "../src/base.js"
        },
        {
            "tags": [
                {
                    "type": "param",
                    "types": [
                        "Function"
                    ],
                    "name": "funct",
                    "description": "- function which will perform the modifcation."
                }
            ],
            "description": {
                "full": "<p>This function returns the internal axes object as a parameter to the<br />supplied function.</p>",
                "summary": "<p>This function returns the internal axes object as a parameter to the<br />supplied function.</p>",
                "body": ""
            },
            "isPrivate": false,
            "ignore": false,
            "code": "chart.axes = function(funct) {\n      if (!arguments.length) {\n        return opts.axes;\n      }\n      funct(opts.axes);\n      return chart;\n    };",
            "ctx": {
                "type": "method",
                "receiver": "chart",
                "name": "axes",
                "string": "chart.axes()"
            },
            "fileName": "../src/base.js"
        },
        {
            "tags": [
                {
                    "type": "param",
                    "types": [
                        "String"
                    ],
                    "name": "name",
                    "description": "- accessor name for chart feature."
                },
                {
                    "type": "param",
                    "types": [
                        "Function"
                    ],
                    "name": "funct",
                    "description": "- function which will perform the modifcation."
                }
            ],
            "description": {
                "full": "<p>The heart of the d4 API is the <code>using</code> function, which allows you to<br />contextually modify attributes of the chart or one of its features.</p>\n\n<h5>Examples</h5>\n\n<pre><code> chart.mixin({ 'zeroLine': d4.features.referenceLine })\n .using('zeroLine', function(zero) {\n   zero\n     .x1(function() {\n       return this.x(0);\n     })\n });\n</code></pre>",
                "summary": "<p>The heart of the d4 API is the <code>using</code> function, which allows you to<br />contextually modify attributes of the chart or one of its features.</p>",
                "body": "<h5>Examples</h5>\n\n<pre><code> chart.mixin({ 'zeroLine': d4.features.referenceLine })\n .using('zeroLine', function(zero) {\n   zero\n     .x1(function() {\n       return this.x(0);\n     })\n });\n</code></pre>"
            },
            "isPrivate": false,
            "ignore": false,
            "code": "chart.using = function(name, funct) {\n      usingFeature.bind(opts)(name, funct);\n      return chart;\n    };\n\n    return chart;\n  };",
            "ctx": {
                "type": "method",
                "receiver": "chart",
                "name": "using",
                "string": "chart.using()"
            },
            "fileName": "../src/base.js"
        },
        {
            "tags": [
                {
                    "type": "param",
                    "types": [
                        "Varies"
                    ],
                    "name": "funct",
                    "description": "- An function or other variable to be wrapped in a function"
                }
            ],
            "description": {
                "full": "<p>Based on D3's own functor function.</p>\n\n<blockquote>\n  <p>If the specified value is a function, returns the specified value. Otherwise,<br />returns a function that returns the specified value. This method is used<br />internally as a lazy way of upcasting constant values to functions, in<br />cases where a property may be specified either as a function or a constant.<br />For example, many D3 layouts allow properties to be specified this way,<br />and it simplifies the implementation if we automatically convert constant<br />values to functions.</p>\n</blockquote>",
                "summary": "<p>Based on D3's own functor function.</p>\n\n<blockquote>\n  <p>If the specified value is a function, returns the specified value. Otherwise,<br />returns a function that returns the specified value. This method is used<br />internally as a lazy way of upcasting constant values to functions, in<br />cases where a property may be specified either as a function or a constant.<br />For example, many D3 layouts allow properties to be specified this way,<br />and it simplifies the implementation if we automatically convert constant<br />values to functions.</p>\n</blockquote>",
                "body": ""
            },
            "isPrivate": false,
            "ignore": false,
            "code": "d4.functor = function(funct) {\n    return d4.isFunction(funct) ? funct : function() {\n      return funct;\n    };\n  };\n\n  d4.isArray = Array.isArray || function(val) {\n    return Object.prototype.toString.call(val) === '[object Array]';\n  };\n\n  d4.isFunction = function(obj) {\n    return !!(obj && obj.constructor && obj.call && obj.apply);\n  };\n\n  d4.isNotFunction = function(obj) {\n    return !d4.isFunction(obj);\n  };\n\n  d4.merge = function(options, overrides) {\n    return d4.extend(d4.extend({}, options), overrides);\n  };\n\n  d4.extend = function(obj) {\n    each(Array.prototype.slice.call(arguments, 1), function(source) {\n      if (source) {\n        for (var prop in source) {\n          if (source[prop] && source[prop].constructor &&\n            source[prop].constructor === Object) {\n            obj[prop] = obj[prop] || {};\n            d4.extend(obj[prop], source[prop]);\n          } else {\n            obj[prop] = source[prop];\n          }\n        }\n      }\n    });\n    return obj;\n  };\n\n}).call(this);",
            "ctx": {
                "type": "method",
                "receiver": "d4",
                "name": "functor",
                "string": "d4.functor()"
            },
            "fileName": "../src/base.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>global d3: false<br />global d4: false</p>",
                "summary": "<p>global d3: false<br />global d4: false</p>",
                "body": ""
            },
            "ignore": true,
            "code": "'use strict';\n\n  var extractValues = function(data, key) {\n    var values = data.map(function(obj) {\n      return obj.values.map(function(i) {\n        return i[key];\n      }.bind(this));\n    }.bind(this));\n    return d3.merge(values);\n  };\n\n  var rangeFor = function(chart, dimension) {\n\n    // This may not be a very robust approach.\n    switch (dimension) {\n      case 'x':\n        return [0, chart.width - chart.margin.left - chart.margin.right];\n      case 'y':\n        return [chart.height - chart.margin.top - chart.margin.bottom, 0];\n      default:\n        return [];\n    }\n  };",
            "fileName": "../src/builders/scales.js"
        },
        {
            "tags": [
                {
                    "type": "param",
                    "types": [
                        "Object"
                    ],
                    "name": "d4",
                    "description": "chart object"
                },
                {
                    "type": "param",
                    "types": [
                        "Array"
                    ],
                    "name": "data",
                    "description": "array"
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "string",
                    "description": "represnting a dimension e.g. `x`,`y`."
                },
                {
                    "type": "returns",
                    "string": "{Object} Chart scale object"
                }
            ],
            "description": {
                "full": "<p>Creates a linear scale for a dimension of a given chart.</p>",
                "summary": "<p>Creates a linear scale for a dimension of a given chart.</p>",
                "body": ""
            },
            "isPrivate": false,
            "ignore": false,
            "code": "d4.builder('linearScaleForNestedData', function(chart, data, dimension) {\n    var key = chart[dimension].$key;\n    var ext = d3.extent(d3.merge(data.map(function(obj) {\n      return d3.extent(obj.values, function(d) {\n        return d[key] + (d.y0 || 0);\n      });\n    })));\n    //chart[dimension] = d3.scale.linear();\n    return chart[dimension].domain([Math.min(0, ext[0]), ext[1]])\n    .range(rangeFor(chart, dimension))\n    .clamp(true)\n    .nice();\n  });",
            "fileName": "../src/builders/scales.js"
        },
        {
            "tags": [
                {
                    "type": "param",
                    "types": [
                        "Object"
                    ],
                    "name": "d4",
                    "description": "chart object"
                },
                {
                    "type": "param",
                    "types": [
                        "Array"
                    ],
                    "name": "data",
                    "description": "array"
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "string",
                    "description": "represnting a dimension e.g. `x`,`y`."
                },
                {
                    "type": "returns",
                    "string": "{Object} Chart scale object"
                }
            ],
            "description": {
                "full": "<p>Creates an ordinal scale for a dimension of a given chart.</p>",
                "summary": "<p>Creates an ordinal scale for a dimension of a given chart.</p>",
                "body": ""
            },
            "isPrivate": false,
            "ignore": false,
            "code": "d4.builder('ordinalScaleForNestedData', function(chart, data, dimension) {\n    var parsedData = extractValues(data, chart[dimension].$key);\n    var bands = chart[dimension + 'RoundBands'] = chart[dimension + 'RoundBands'] || 0.3;\n    //chart[dimension] = d3.scale.ordinal();\n    return chart[dimension]\n      .domain(parsedData)\n      .rangeRoundBands(rangeFor(chart, dimension), bands);\n  });\n}).call(this);",
            "fileName": "../src/builders/scales.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>global d3: false<br />global d4: false</p>",
                "summary": "<p>global d3: false<br />global d4: false</p>",
                "body": ""
            },
            "ignore": true,
            "code": "'use strict';\n\n  var columnChartBuilder = function() {\n    var builder = {\n      link: function(chart, data) {\n        d4.builders.ordinalScaleForNestedData(chart, data, 'x');\n        d4.builders.linearScaleForNestedData(chart, data, 'y');\n      }\n    };\n    return builder;\n  };",
            "fileName": "../src/charts/column.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>The column chart has two axes (<code>x</code> and <code>y</code>). By default the column chart expects<br />   linear values for the <code>y</code> and ordinal values on the <code>x</code>. The basic column chart<br />   has four default features:</p>\n\n<p><strong>bars</strong> - series bars<br /><strong>barLabels</strong> - data labels above the bars<br /><strong>xAxis</strong> - the axis for the x dimension<br /><strong>yAxis</strong> - the axis for the y dimension</p>\n\n<h5>Example Usage</h5>\n\n<pre><code>var data = [\n    { x: '2010', y:-10 },\n    { x: '2011', y:20 },\n    { x: '2012', y:30 },\n    { x: '2013', y:40 },\n    { x: '2014', y:50 },\n  ];\nvar chart = d4.charts.column();\nd3.select('#example')\n.datum(data)\n.call(chart);\n</code></pre>\n\n<p>By default d4 expects a series object, which uses the following format: <code>{ x : '2010', y : 10 }</code>.<br />The default format may not be desired and so we'll override it:</p>\n\n<pre><code>var data = [\n  ['2010', -10],\n  ['2011', 20],\n  ['2012', 30],\n  ['2013', 40],\n  ['2014', 50]\n];\nvar chart = d4.charts.column()\n.x.$key(0)\n.y.$key(1);\n\nd3.select('#example')\n.datum(data)\n.call(chart);\n</code></pre>",
                "summary": "<p>The column chart has two axes (<code>x</code> and <code>y</code>). By default the column chart expects<br />   linear values for the <code>y</code> and ordinal values on the <code>x</code>. The basic column chart<br />   has four default features:</p>",
                "body": "<p><strong>bars</strong> - series bars<br /><strong>barLabels</strong> - data labels above the bars<br /><strong>xAxis</strong> - the axis for the x dimension<br /><strong>yAxis</strong> - the axis for the y dimension</p>\n\n<h5>Example Usage</h5>\n\n<pre><code>var data = [\n    { x: '2010', y:-10 },\n    { x: '2011', y:20 },\n    { x: '2012', y:30 },\n    { x: '2013', y:40 },\n    { x: '2014', y:50 },\n  ];\nvar chart = d4.charts.column();\nd3.select('#example')\n.datum(data)\n.call(chart);\n</code></pre>\n\n<p>By default d4 expects a series object, which uses the following format: <code>{ x : '2010', y : 10 }</code>.<br />The default format may not be desired and so we'll override it:</p>\n\n<pre><code>var data = [\n  ['2010', -10],\n  ['2011', 20],\n  ['2012', 30],\n  ['2013', 40],\n  ['2014', 50]\n];\nvar chart = d4.charts.column()\n.x.$key(0)\n.y.$key(1);\n\nd3.select('#example')\n.datum(data)\n.call(chart);\n</code></pre>"
            },
            "ignore": false,
            "code": "d4.chart('column', function columnChart() {\n    var chart = d4.baseChart(columnChartBuilder);\n    [{\n      'bars': d4.features.stackedColumnSeries\n    }, {\n      'barLabels': d4.features.stackedColumnLabels\n    }, {\n      'xAxis': d4.features.xAxis\n    }, {\n      'yAxis': d4.features.yAxis\n    }].forEach(function(feature) {\n      chart.mixin(feature);\n    });\n    return chart;\n  });\n}).call(this);",
            "fileName": "../src/charts/column.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>global d3: false<br />global d4: false</p>",
                "summary": "<p>global d3: false<br />global d4: false</p>",
                "body": ""
            },
            "ignore": true,
            "code": "'use strict';\n\n  var groupedColumnChartBuilder = function() {\n    var builder = {\n      link: function(chart, data) {\n        d4.builders.ordinalScaleForNestedData(chart, data, 'x');\n        d4.builders.linearScaleForNestedData(chart, data, 'y');\n      }\n    };\n    return builder;\n  };",
            "fileName": "../src/charts/grouped-column.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>The grouped column chart is used to compare a series of data elements grouped<br />along the xAxis. This chart is often useful in conjunction with a stacked column<br />chart because they can use the same data series, and where the stacked column highlights<br />the sum of the data series across an axis the grouped column can be used to show the<br />relative distribution.</p>\n\n<p><strong>bars</strong> - series bars<br /><strong>barLabels</strong> - data labels above the bars<br /><strong>groupsOf</strong> - an integer representing the number of columns in each group<br /><strong>xAxis</strong> - the axis for the x dimension<br /><strong>yAxis</strong> - the axis for the y dimension</p>\n\n<h5>Example Usage</h5>\n\n<pre><code>var data = [\n  { year: '2010', unitsSold:-100, salesman : 'Bob' },\n  { year: '2011', unitsSold:200, salesman : 'Bob' },\n  { year: '2012', unitsSold:300, salesman : 'Bob' },\n  { year: '2013', unitsSold:400, salesman : 'Bob' },\n  { year: '2014', unitsSold:500, salesman : 'Bob' },\n  { year: '2010', unitsSold:100, salesman : 'Gina' },\n  { year: '2011', unitsSold:100, salesman : 'Gina' },\n  { year: '2012', unitsSold:-100, salesman : 'Gina' },\n  { year: '2013', unitsSold:500, salesman : 'Gina' },\n  { year: '2014', unitsSold:600, salesman : 'Gina' },\n  { year: '2010', unitsSold:400, salesman : 'Average' },\n  { year: '2011', unitsSold:0, salesman : 'Average' },\n  { year: '2012', unitsSold:400, salesman : 'Average' },\n  { year: '2013', unitsSold:400, salesman : 'Average' },\n  { year: '2014', unitsSold:400, salesman : 'Average' }\n];\n\nvar parsedData = d4.parsers.nestedGroup()\n  .x('year')\n  .y('unitsSold')\n  .value('unitsSold')(data);\n\nvar chart = d4.charts.groupedColumn()\n.width($('#example').width())\n.x.$key('year')\n.y.$key('unitsSold')\n.groupsOf(parsedData.data[0].values.length);\n\nd3.select('#example')\n.datum(parsedData.data)\n.call(chart);\n</code></pre>",
                "summary": "<p>The grouped column chart is used to compare a series of data elements grouped<br />along the xAxis. This chart is often useful in conjunction with a stacked column<br />chart because they can use the same data series, and where the stacked column highlights<br />the sum of the data series across an axis the grouped column can be used to show the<br />relative distribution.</p>",
                "body": "<p><strong>bars</strong> - series bars<br /><strong>barLabels</strong> - data labels above the bars<br /><strong>groupsOf</strong> - an integer representing the number of columns in each group<br /><strong>xAxis</strong> - the axis for the x dimension<br /><strong>yAxis</strong> - the axis for the y dimension</p>\n\n<h5>Example Usage</h5>\n\n<pre><code>var data = [\n  { year: '2010', unitsSold:-100, salesman : 'Bob' },\n  { year: '2011', unitsSold:200, salesman : 'Bob' },\n  { year: '2012', unitsSold:300, salesman : 'Bob' },\n  { year: '2013', unitsSold:400, salesman : 'Bob' },\n  { year: '2014', unitsSold:500, salesman : 'Bob' },\n  { year: '2010', unitsSold:100, salesman : 'Gina' },\n  { year: '2011', unitsSold:100, salesman : 'Gina' },\n  { year: '2012', unitsSold:-100, salesman : 'Gina' },\n  { year: '2013', unitsSold:500, salesman : 'Gina' },\n  { year: '2014', unitsSold:600, salesman : 'Gina' },\n  { year: '2010', unitsSold:400, salesman : 'Average' },\n  { year: '2011', unitsSold:0, salesman : 'Average' },\n  { year: '2012', unitsSold:400, salesman : 'Average' },\n  { year: '2013', unitsSold:400, salesman : 'Average' },\n  { year: '2014', unitsSold:400, salesman : 'Average' }\n];\n\nvar parsedData = d4.parsers.nestedGroup()\n  .x('year')\n  .y('unitsSold')\n  .value('unitsSold')(data);\n\nvar chart = d4.charts.groupedColumn()\n.width($('#example').width())\n.x.$key('year')\n.y.$key('unitsSold')\n.groupsOf(parsedData.data[0].values.length);\n\nd3.select('#example')\n.datum(parsedData.data)\n.call(chart);\n</code></pre>"
            },
            "ignore": false,
            "code": "d4.chart('groupedColumn', function groupedColumnChart() {\n    var chart = d4.baseChart(groupedColumnChartBuilder, {\n      accessors: ['groupsOf'],\n      groupsOf: 1\n    });\n    [{\n      'bars': d4.features.groupedColumnSeries\n    }, {\n      'columnLabels': d4.features.groupedColumnLabels\n    }, {\n      'xAxis': d4.features.xAxis\n    }, {\n      'yAxis': d4.features.yAxis\n    }].forEach(function(feature) {\n      chart.mixin(feature);\n    });\n    return chart;\n  });\n}).call(this);",
            "fileName": "../src/charts/grouped-column.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>global d3: false<br />global d4: false</p>",
                "summary": "<p>global d3: false<br />global d4: false</p>",
                "body": ""
            },
            "ignore": true,
            "code": "'use strict';\n\n  var lineChartBuilder = function() {\n    var builder = {\n      link: function(chart, data) {\n        d4.builders.ordinalScaleForNestedData(chart, data, 'x');\n        d4.builders.linearScaleForNestedData(chart, data, 'y');\n      }\n    };\n    return builder;\n  };",
            "fileName": "../src/charts/line.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>The line series chart is used to compare a series of data elements grouped<br />  along the xAxis.</p>\n\n<p><strong>lineSeries</strong> - series lines<br /><strong>lineSeriesLabels</strong> - data labels beside the lines<br /><strong>xAxis</strong> - the axis for the x dimension<br /><strong>yAxis</strong> - the axis for the y dimension</p>\n\n<h5>Example Usage</h5>\n\n<pre><code>var data = [\n  { year: '2010', unitsSold:-100, salesman : 'Bob' },\n  { year: '2011', unitsSold:200, salesman : 'Bob' },\n  { year: '2012', unitsSold:300, salesman : 'Bob' },\n  { year: '2013', unitsSold:400, salesman : 'Bob' },\n  { year: '2014', unitsSold:500, salesman : 'Bob' },\n  { year: '2010', unitsSold:100, salesman : 'Gina' },\n  { year: '2011', unitsSold:100, salesman : 'Gina' },\n  { year: '2012', unitsSold:-100, salesman : 'Gina' },\n  { year: '2013', unitsSold:500, salesman : 'Gina' },\n  { year: '2014', unitsSold:600, salesman : 'Gina' },\n  { year: '2010', unitsSold:400, salesman : 'Average' },\n  { year: '2011', unitsSold:0, salesman : 'Average' },\n  { year: '2012', unitsSold:400, salesman : 'Average' },\n  { year: '2013', unitsSold:400, salesman : 'Average' },\n  { year: '2014', unitsSold:400, salesman : 'Average' }\n];\nvar parsedData = d4.parsers.nestedGroup()\n  .x(function(){\n    return 'year';\n  })\n  .nestKey(function(){\n    return 'salesman';\n  })\n  .y(function(){\n    return 'unitsSold';\n  })\n  .value(function(){\n    return 'unitsSold';\n  })(data);\n\nvar chart = d4.charts.line()\n.width($('#example').width())\n.x.$key('year')\n.y.$key('unitsSold');\n\nd3.select('#example')\n.datum(parsedData.data)\n.call(chart);\n</code></pre>",
                "summary": "<p>The line series chart is used to compare a series of data elements grouped<br />  along the xAxis.</p>",
                "body": "<p><strong>lineSeries</strong> - series lines<br /><strong>lineSeriesLabels</strong> - data labels beside the lines<br /><strong>xAxis</strong> - the axis for the x dimension<br /><strong>yAxis</strong> - the axis for the y dimension</p>\n\n<h5>Example Usage</h5>\n\n<pre><code>var data = [\n  { year: '2010', unitsSold:-100, salesman : 'Bob' },\n  { year: '2011', unitsSold:200, salesman : 'Bob' },\n  { year: '2012', unitsSold:300, salesman : 'Bob' },\n  { year: '2013', unitsSold:400, salesman : 'Bob' },\n  { year: '2014', unitsSold:500, salesman : 'Bob' },\n  { year: '2010', unitsSold:100, salesman : 'Gina' },\n  { year: '2011', unitsSold:100, salesman : 'Gina' },\n  { year: '2012', unitsSold:-100, salesman : 'Gina' },\n  { year: '2013', unitsSold:500, salesman : 'Gina' },\n  { year: '2014', unitsSold:600, salesman : 'Gina' },\n  { year: '2010', unitsSold:400, salesman : 'Average' },\n  { year: '2011', unitsSold:0, salesman : 'Average' },\n  { year: '2012', unitsSold:400, salesman : 'Average' },\n  { year: '2013', unitsSold:400, salesman : 'Average' },\n  { year: '2014', unitsSold:400, salesman : 'Average' }\n];\nvar parsedData = d4.parsers.nestedGroup()\n  .x(function(){\n    return 'year';\n  })\n  .nestKey(function(){\n    return 'salesman';\n  })\n  .y(function(){\n    return 'unitsSold';\n  })\n  .value(function(){\n    return 'unitsSold';\n  })(data);\n\nvar chart = d4.charts.line()\n.width($('#example').width())\n.x.$key('year')\n.y.$key('unitsSold');\n\nd3.select('#example')\n.datum(parsedData.data)\n.call(chart);\n</code></pre>"
            },
            "ignore": false,
            "code": "d4.chart('line', function lineChart() {\n    var chart = d4.baseChart(lineChartBuilder);\n    [{\n      'lineSeries': d4.features.lineSeries\n    },{\n      'lineSeriesLabels': d4.features.lineSeriesLabels\n    }, {\n      'xAxis': d4.features.xAxis\n    }, {\n      'yAxis': d4.features.yAxis\n    }].forEach(function(feature) {\n      chart.mixin(feature);\n    });\n    return chart;\n  });\n}).call(this);",
            "fileName": "../src/charts/line.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>global d3: false<br />global d4: false</p>",
                "summary": "<p>global d3: false<br />global d4: false</p>",
                "body": ""
            },
            "ignore": true,
            "code": "'use strict';\n\n  var rowChartBuilder = function() {\n    var builder = {\n      link: function(chart, data) {\n        d4.builders.linearScaleForNestedData(chart, data, 'x');\n        d4.builders.ordinalScaleForNestedData(chart, data, 'y');\n      }\n    };\n    return builder;\n  };",
            "fileName": "../src/charts/row.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>The row chart has two axes (<code>x</code> and <code>y</code>). By default the column chart expects<br />   linear scale values for the <code>x</code> and ordinal scale values on the <code>y</code>. The basic column chart<br />   has four default features:</p>\n\n<p><strong>bars</strong> - series bars<br /><strong>rowLabels</strong> - data labels to the right of the bars<br /><strong>xAxis</strong> - the axis for the x dimension<br /><strong>yAxis</strong> - the axis for the y dimension</p>\n\n<h5>Example Usage</h5>\n\n<pre><code>var data = [\n      { y: '2010', x:-10 },\n      { y: '2011', x:20 },\n      { y: '2012', x:30 },\n      { y: '2013', x:40 },\n      { y: '2014', x:50 },\n    ];\n  var chart = d4.charts.row();\n  d3.select('#example')\n  .datum(data)\n  .call(chart);\n</code></pre>",
                "summary": "<p>The row chart has two axes (<code>x</code> and <code>y</code>). By default the column chart expects<br />   linear scale values for the <code>x</code> and ordinal scale values on the <code>y</code>. The basic column chart<br />   has four default features:</p>",
                "body": "<p><strong>bars</strong> - series bars<br /><strong>rowLabels</strong> - data labels to the right of the bars<br /><strong>xAxis</strong> - the axis for the x dimension<br /><strong>yAxis</strong> - the axis for the y dimension</p>\n\n<h5>Example Usage</h5>\n\n<pre><code>var data = [\n      { y: '2010', x:-10 },\n      { y: '2011', x:20 },\n      { y: '2012', x:30 },\n      { y: '2013', x:40 },\n      { y: '2014', x:50 },\n    ];\n  var chart = d4.charts.row();\n  d3.select('#example')\n  .datum(data)\n  .call(chart);\n</code></pre>"
            },
            "ignore": false,
            "code": "d4.chart('row', function rowChart() {\n    var chart = d4.baseChart(rowChartBuilder, {\n      margin: {\n        top: 20,\n        right: 40,\n        bottom: 20,\n        left: 40\n      },\n      axes: {\n        x : {\n          scale : 'linear'\n        },\n        y : {\n          scale : 'ordinal'\n        }\n      }\n    });\n    [{\n      'bars': d4.features.rowSeries\n    }, {\n      'rowLabels': d4.features.rowLabels\n    }, {\n      'xAxis': d4.features.xAxis\n    }, {\n      'yAxis': d4.features.yAxis\n    }].forEach(function(feature) {\n      chart.mixin(feature);\n    });\n    return chart;\n  });\n}).call(this);",
            "fileName": "../src/charts/row.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>global d3: false<br />global d4: false</p>",
                "summary": "<p>global d3: false<br />global d4: false</p>",
                "body": ""
            },
            "ignore": true,
            "code": "'use strict';\n\n  var scatterPlotBuilder = function() {\n    var configureScales = function(chart, data) {\n      d4.builders.linearScaleForNestedData(chart, data, 'x');\n      d4.builders.linearScaleForNestedData(chart, data, 'y');\n      d4.builders.linearScaleForNestedData(chart, data, 'z');\n      var min = 5;\n      var max = Math.max(min + 1, (chart.height - chart.margin.top - chart.margin.bottom)/10);\n      chart.z.range([min, max]);\n    };\n\n    var builder = {\n      link: function(chart, data) {\n        configureScales.bind(this)(chart, data);\n      }\n    };\n    return builder;\n  };\n\n  d4.chart('scatterPlot', function() {\n    var chart = d4.baseChart(scatterPlotBuilder, {\n      axes : {\n        x : {\n          scale : 'linear'\n        },\n        z : {\n          scale : 'linear'\n        }\n      }\n    });\n    [{\n      'circles': d4.features.dotSeries\n    }, {\n      'xAxis': d4.features.xAxis\n    }, {\n      'yAxis': d4.features.yAxis\n    }].forEach(function(feature) {\n      chart.mixin(feature);\n    });\n    return chart;\n  });\n}).call(this);",
            "fileName": "../src/charts/scatter.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>global d3: false<br />global d4: false</p>",
                "summary": "<p>global d3: false<br />global d4: false</p>",
                "body": ""
            },
            "ignore": true,
            "code": "'use strict';\n\n  var stackedColumnChartBuilder = function() {\n    var builder = {\n      link: function(chart, data) {\n        d4.builders.ordinalScaleForNestedData(chart, data, 'x');\n        d4.builders.linearScaleForNestedData(chart, data, 'y');\n      }\n    };\n    return builder;\n  };\n\n  d4.chart('stackedColumn', function stackedColumnChart() {\n    var chart = d4.baseChart(stackedColumnChartBuilder);\n    [{\n      'bars': d4.features.stackedColumnSeries\n    }, {\n      'barLabels': d4.features.stackedColumnLabels\n    }, {\n      'connectors': d4.features.stackedColumnConnectors\n    }, {\n      'xAxis': d4.features.xAxis\n    }, {\n      'yAxis': d4.features.yAxis\n    }].forEach(function(feature) {\n      chart.mixin(feature);\n    });\n    return chart;\n  });\n}).call(this);",
            "fileName": "../src/charts/stacked-column.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>global d3: false<br />global d4: false</p>",
                "summary": "<p>global d3: false<br />global d4: false</p>",
                "body": ""
            },
            "ignore": true,
            "code": "'use strict';\n\n  // This accessor can be overridden\n  var orientation = function() {\n    return 'vertical';\n  };\n\n  // FIXME: It would be nice not to continually have to check the orientation.\n  var columnSeriesOverrides = function() {\n    return {\n      accessors: {\n        y: function(d) {\n          if (this.orientation() === 'vertical') {\n            var yVal = (d.y0 + d.y) - Math.min(0, d.y);\n            return this.y(yVal);\n          } else {\n            return this.y(d[this.y.$key]);\n          }\n        },\n\n        x: function(d) {\n          if (this.orientation() === 'vertical') {\n            return this.x(d[this.x.$key]);\n          } else {\n            var xVal = (d.y0 + d.y) - Math.max(0, d.y);\n            return this.x(xVal);\n          }\n        },\n\n        width: function(d) {\n          if (this.orientation() === 'vertical') {\n            return this.x.rangeBand();\n          } else {\n            return Math.abs(this.x(d.y0) - this.x(d.y0 + d.y));\n          }\n        },\n\n        height: function(d) {\n          if (this.orientation() === 'vertical') {\n            return Math.abs(this.y(d.y0) - this.y(d.y0 + d.y));\n          } else {\n            return this.y.rangeBand();\n          }\n        },\n\n        classes: function(d, i, n) {\n          var klass = (d.y > 0) ? 'positive' : 'negative';\n          if (n > 0 && d.y0 === 0) {\n            klass = 'subtotal';\n          }\n          return 'bar fill item' + i + ' ' + klass + ' ' + d[this.y.$key];\n        }\n      }\n    };\n  };\n\n  var columnLabelOverrides = function() {\n    return {\n      accessors: {\n        y: function(d) {\n          if (this.orientation() === 'vertical') {\n            var height = Math.abs(this.y(d.y0) - this.y(d.y0 + d.y));\n            var yVal = (d.y0 + d.y) - Math.max(0, d.y);\n            return this.y(yVal) - 10 - height;\n          } else {\n            return this.y(d[this.y.$key]) + (this.y.rangeBand() / 2);\n          }\n        },\n\n        x: function(d) {\n          if (this.orientation() === 'vertical') {\n            return this.x(d[this.x.$key]) + (this.x.rangeBand() / 2);\n          } else {\n            var xVal = (d.y0 + d.y) - Math.max(0, d.y);\n            var width = Math.abs(this.x(d.y0) - this.x(d.y0 + d.y));\n            return this.x(xVal) + 10 + width;\n          }\n        },\n\n        text: function(d) {\n          return d3.format('').call(this, d[this.valueKey]);\n        }\n      }\n    };\n  };\n\n  var waterfallChartBuilder = function() {\n    var rangeBoundsFor = function(chart, dimension) {\n      var rangeBounds;\n      if (dimension === 'x') {\n        return [0, chart.width - chart.margin.left - chart.margin.right];\n      } else {\n        rangeBounds = [0, chart.height - chart.margin.top - chart.margin.bottom];\n        return (chart.orientation().toLowerCase() === 'vertical') ? rangeBounds.reverse() : rangeBounds;\n      }\n    };\n\n    var setOrdinal = function(chart, dimension, data) {\n      var keys = data.map(function(d) {\n        return d.key;\n      }.bind(this));\n\n      chart[dimension]\n      .domain(keys)\n      .rangeRoundBands(rangeBoundsFor.bind(this)(chart, dimension), chart.xRoundBands || 0.3);\n    };\n\n    var setLinear = function(chart, dimension, data) {\n        var ext = d3.extent(d3.merge(data.map(function(datum) {\n          return d3.extent(datum.values, function(d) {\n\n            // This is anti-intuative but the stack only returns y and y0 even\n            // when it applies to the x dimension;\n            return d.y + d.y0;\n          });\n        })));\n        ext[0] = Math.min(0, ext[0]);\n        chart[dimension].domain(ext);\n        chart[dimension].range(rangeBoundsFor.bind(this)(chart, dimension))\n        .clamp(true)\n        .nice();\n      };\n\n    var configureScales = function(chart, data) {\n      if (chart.orientation().toLowerCase() === 'vertical') {\n        setOrdinal.bind(this)(chart, 'x', data);\n        setLinear.bind(this)(chart, 'y', data);\n      } else {\n        setOrdinal.bind(this)(chart, 'y', data);\n        setLinear.bind(this)(chart, 'x', data);\n      }\n    };\n\n    var builder = {\n      link: function(chart, data) {\n        configureScales.bind(this)(chart, data);\n      }\n    };\n    return builder;\n  };\n\n  d4.chart('waterfall', function waterfallChart() {\n    var chart = d4.baseChart(waterfallChartBuilder, {\n      accessors: ['orientation'],\n      orientation: orientation\n    });\n    [{\n      'bars': d4.features.stackedColumnSeries,\n      'overrides': columnSeriesOverrides\n    }, {\n      'connectors': d4.features.waterfallConnectors\n    }, {\n      'columnLabels': d4.features.stackedColumnLabels,\n      'overrides': columnLabelOverrides\n    }, {\n      'xAxis': d4.features.xAxis\n    }, {\n      'yAxis': d4.features.yAxis\n    }].forEach(function(feature) {\n      chart.mixin(feature);\n    });\n\n    return chart;\n  });\n}).call(this);",
            "fileName": "../src/charts/waterfall.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>global d3: false<br />global d4: false</p>",
                "summary": "<p>global d3: false<br />global d4: false</p>",
                "body": ""
            },
            "ignore": true,
            "code": "'use strict';\n  d4.feature('arrow', function(name) {\n    return {\n      accessors: {\n        tipSize: function(){\n          return 6;\n        },\n        x1: function() {\n          return this.x(0);\n        },\n\n        x2: function() {\n          return this.x(this.width - this.margin.left - this.margin.right);\n        },\n\n        y1: function() {\n          return this.y(0);\n        },\n\n        y2: function() {\n          return  this.y(this.height - this.margin.top - this.margin.bottom);\n        }\n      },\n      render: function(scope) {\n        var defs = this.svg.select('defs');\n\n        defs.append('marker')\n          .attr('id', name + '-end')\n          .attr('viewBox', '0 0 10 10')\n          .attr('refX', 10)\n          .attr('refY', 5)\n          .attr('markerWidth', scope.accessors.tipSize.bind(this))\n          .attr('markerHeight', scope.accessors.tipSize.bind(this))\n          .attr('orient', 'auto')\n          .append('path')\n          .attr('d', 'M 0 0 L 10 5 L 0 10 z');\n\n        defs.append('marker')\n          .attr('id', name + '-start')\n          .attr('viewBox', '0 0 10 10')\n          .attr('refX', 10)\n          .attr('refY', 5)\n          .attr('markerWidth', -scope.accessors.tipSize.bind(this)())\n          .attr('markerHeight', scope.accessors.tipSize.bind(this))\n          .attr('orient', 'auto')\n          .append('path')\n          .attr('d', 'M 0 0 L 10 5 L 0 10 z');\n\n        this.featuresGroup.append('g').attr('class', name);\n        var arrow = this.svg.select('.' + name)\n          .append('line')\n          .attr('class', 'line')\n          .attr('x1', scope.accessors.x1.bind(this))\n          .attr('x2', scope.accessors.x2.bind(this))\n          .attr('y1', scope.accessors.y1.bind(this))\n          .attr('y2', scope.accessors.y2.bind(this))\n          .attr('marker-end', 'url(#' + name + '-end)');\n\n        return arrow;\n      }\n    };\n  });\n}).call(this);",
            "fileName": "../src/features/arrow.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>global d3: false<br />global d4: false</p>",
                "summary": "<p>global d3: false<br />global d4: false</p>",
                "body": ""
            },
            "ignore": true,
            "code": "'use strict';\n  d4.feature('dotSeries', function(name) {\n    return {\n      accessors: {\n        cx: function(d) {\n          return this.x(d[this.x.$key]);\n        },\n\n        cy: function(d) {\n          return this.y(d[this.y.$key]);\n        },\n\n        r: function(d) {\n          return this.z(d[this.z.$key]);\n        },\n\n        classes : function(d, i) {\n          return 'dot series' + i + ' fill';\n        }\n      },\n      render: function(scope, data) {\n        this.featuresGroup.append('g').attr('class', name);\n        var group = this.svg.select('.' + name).selectAll('.group')\n          .data(data)\n          .enter().append('g')\n          .attr('class', function(d,i) {\n            return 'series'+ i + ' ' +  this.y.$key;\n          }.bind(this));\n\n        var dots = group.selectAll('circle')\n          .data(function(d) {\n            return d.values;\n          }.bind(this));\n\n        dots.enter().append('circle');\n        dots.exit().remove();\n        dots\n          .attr('class', scope.accessors.classes.bind(this))\n          .attr('r', scope.accessors.r.bind(this))\n          .attr('cx', scope.accessors.cx.bind(this))\n          .attr('cy', scope.accessors.cy.bind(this));\n        return dots;\n      }\n    };\n  });\n}).call(this);",
            "fileName": "../src/features/dot-series.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>global d3: false<br />global d4: false</p>",
                "summary": "<p>global d3: false<br />global d4: false</p>",
                "body": ""
            },
            "ignore": true,
            "code": "'use strict';\n  d4.feature('grid', function(name) {\n\n    return {\n      accessors: {\n        formatXAxis: function(xAxis) {\n          return xAxis.orient('bottom');\n        },\n\n        formatYAxis: function(yAxis) {\n          return yAxis.orient('left');\n        }\n      },\n      render: function(scope) {\n        var xAxis = d3.svg.axis().scale(this.x);\n        var yAxis = d3.svg.axis().scale(this.y);\n        var formattedXAxis = scope.accessors.formatXAxis.bind(this)(xAxis);\n        var formattedYAxis = scope.accessors.formatYAxis.bind(this)(yAxis);\n\n        this.featuresGroup.append('g').attr('class', 'grid border '+ name)\n          .attr('transform', 'translate(0,0)')\n          .append('rect')\n          .attr('x', 0)\n          .attr('y', 0)\n          .attr('width', this.width - this.margin.left - this.margin.right)\n          .attr('height', this.height - this.margin.top - this.margin.bottom);\n\n        this.featuresGroup.append('g').attr('class', 'x grid '+ name)\n          .attr('transform', 'translate(0,' + (this.height - this.margin.top - this.margin.bottom) + ')')\n          .call(formattedXAxis\n          .tickSize(-(this.height - this.margin.top - this.margin.bottom), 0, 0)\n          .tickFormat(''));\n\n        this.featuresGroup.append('g').attr('class', 'y grid '+ name)\n          .attr('transform', 'translate(0,0)')\n          .call(formattedYAxis\n          .tickSize(-(this.width - this.margin.left - this.margin.right), 0, 0)\n          .tickFormat(''));\n      }\n    };\n  });\n}).call(this);",
            "fileName": "../src/features/grid.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>global d3: false<br />global d4: false</p>",
                "summary": "<p>global d3: false<br />global d4: false</p>",
                "body": ""
            },
            "ignore": true,
            "code": "'use strict';\n  d4.feature('groupedColumnLabels', function(name) {\n    return {\n      accessors: {\n        x: function(d, i) {\n          var width = this.x.rangeBand() / this.groupsOf;\n          var xPos = this.x(d[this.x.$key]) + width * i;\n          var gutter = width * 0.1;\n          return xPos + width/2 - gutter;\n        },\n\n        y: function(d) {\n          return (d[this.y.$key] < 0 ? this.y(0) : this.y(d[this.y.$key])) -5;\n        },\n\n        text: function(d) {\n          return d3.format('').call(this, d[this.y.$key]);\n        }\n      },\n      render: function(scope, data) {\n        this.featuresGroup.append('g').attr('class', name);\n        var group = this.svg.select('.' + name).selectAll('.group')\n          .data(data)\n          .enter().append('g')\n          .attr('class', function(d,i) {\n            return 'series'+ i +  ' ' + this.x.$key;\n          }.bind(this));\n\n        var text = group.selectAll('text')\n          .data(function(d) {\n            return d.values;\n          }.bind(this));\n        text.exit().remove();\n        text.enter().append('text')\n          .attr('class', 'column-label')\n          .text(scope.accessors.text.bind(this))\n          .attr('y', scope.accessors.y.bind(this))\n          .attr('x', scope.accessors.x.bind(this));\n        return text;\n      }\n    };\n  });\n}).call(this);",
            "fileName": "../src/features/grouped-column-labels.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>global d3: false<br />global d4: false</p>",
                "summary": "<p>global d3: false<br />global d4: false</p>",
                "body": ""
            },
            "ignore": true,
            "code": "'use strict';\n  d4.feature('groupedColumnSeries', function(name) {\n    var sign = function(val) {\n      return (val > 0) ? 'positive' : 'negative';\n    };\n\n    return {\n      accessors: {\n        x: function(d, i) {\n          var width = this.x.rangeBand() / this.groupsOf;\n          var xPos = this.x(d[this.x.$key]) + width * i;\n          return xPos;\n        },\n\n        y: function(d) {\n          return d[this.y.$key] < 0 ? this.y(0) : this.y(d[this.y.$key]);\n        },\n\n        width: function() {\n          var width = this.x.rangeBand() / this.groupsOf;\n          var gutter = width * 0.1;\n          return width - gutter;\n        },\n\n        height: function(d) {\n          return Math.abs(this.y(d[this.y.$key]) - this.y(0));\n        },\n\n        classes: function(d, i) {\n          return 'bar fill item' + i + ' ' + sign(d[this.y.$key]) + ' ' + d[this.y.$key];\n        }\n      },\n      render: function(scope, data) {\n        this.featuresGroup.append('g').attr('class', name);\n        var group = this.svg.select('.' + name).selectAll('.group')\n          .data(data);\n        group.enter().append('g');\n        group.exit().remove();\n        group.attr('class', function(d, i) {\n          return 'series' + i + ' ' + this.x.$key;\n        }.bind(this));\n\n        var rect = group.selectAll('rect')\n          .data(function(d) {\n            return d.values;\n          }.bind(this));\n        rect.enter().append('rect')\n          .attr('class', scope.accessors.classes.bind(this))\n          .attr('x', scope.accessors.x.bind(this))\n          .attr('y', scope.accessors.y.bind(this))\n          .attr('width', scope.accessors.width.bind(this))\n          .attr('height', scope.accessors.height.bind(this));\n        return rect;\n      }\n    };\n  });\n}).call(this);",
            "fileName": "../src/features/grouped-column-series.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>global d3: false<br />global d4: false</p>",
                "summary": "<p>global d3: false<br />global d4: false</p>",
                "body": ""
            },
            "ignore": true,
            "code": "'use strict';\n  d4.feature('lineSeriesLabels', function(name) {\n    return {\n      accessors: {\n        x: function(d) {\n          return this.x(d.values[d.values.length - 1][this.x.$key]);\n        },\n\n        y: function(d) {\n          return this.y(d.values[d.values.length - 1][this.y.$key]);\n        },\n\n        text: function(d) {\n          return d.key;\n        },\n\n        classes: function(d,n) {\n          return 'stroke series' + n;\n        }\n      },\n      render: function(scope, data) {\n        this.featuresGroup.append('g').attr('class', name);\n        var label = this.svg.select('.'+name).selectAll('.'+name).data(data);\n        label.enter().append('text');\n        label.exit().remove();\n        label.attr('class', 'lineSeriesLabel')\n          .text(scope.accessors.text.bind(this))\n          .attr('x', scope.accessors.x.bind(this))\n          .attr('y', scope.accessors.y.bind(this))\n          .attr('data-key', function(d){\n            return d.key;\n          })\n          .attr('class', scope.accessors.classes.bind(this));\n        return label;\n      }\n    };\n  });\n}).call(this);",
            "fileName": "../src/features/line-series-labels.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>global d3: false<br />global d4: false</p>",
                "summary": "<p>global d3: false<br />global d4: false</p>",
                "body": ""
            },
            "ignore": true,
            "code": "'use strict';\n  d4.feature('lineSeries', function(name) {\n    return {\n      accessors: {\n        x: function(d) {\n          return this.x(d[this.x.$key]);\n        },\n        y: function(d) {\n          return this.y(d[this.y.$key]);\n        },\n        interpolate: function() {\n          return 'basis';\n        },\n        classes: function(d, n) {\n          return 'line stroke series' + n;\n        }\n      },\n      render: function(scope, data) {\n        this.featuresGroup.append('g').attr('class', name);\n        var line = d3.svg.line()\n          .interpolate(scope.accessors.interpolate.bind(this)())\n          .x(scope.accessors.x.bind(this))\n          .y(scope.accessors.y.bind(this));\n\n        var group = this.svg.select('.' + name).selectAll('.group')\n          .data(data);\n        group.exit().remove();\n        group.enter().append('g')\n          .attr('data-key', function(d) {\n            return d.key;\n          })\n          .attr('class', function(d, i) {\n            return 'series' + i;\n          }.bind(this))\n          .append('path')\n          .attr('d', function(d) {\n            return line(d.values);\n          });\n      }\n    };\n  });\n}).call(this);",
            "fileName": "../src/features/line-series.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>global d3: false<br />global d4: false</p>",
                "summary": "<p>global d3: false<br />global d4: false</p>",
                "body": ""
            },
            "ignore": true,
            "code": "'use strict';\n  d4.feature('referenceLine', function(name) {\n    return {\n      accessors: {\n        x1: function() {\n          return this.x(0);\n        },\n\n        x2: function() {\n          return this.x(this.width - this.margin.left - this.margin.right);\n        },\n\n        y1: function() {\n          return this.y(0);\n        },\n\n        y2: function() {\n          return this.y(this.height);\n        }\n      },\n      render: function(scope) {\n        this.featuresGroup.append('g').attr('class', name);\n        var referenceLine = this.svg.select('.' + name)\n          .append('line')\n          .attr('class', 'line')\n          .attr('x1', scope.accessors.x1.bind(this))\n          .attr('x2', scope.accessors.x2.bind(this))\n          .attr('y1', scope.accessors.y1.bind(this))\n          .attr('y2', scope.accessors.y2.bind(this));\n        return referenceLine;\n      }\n    };\n  });\n}).call(this);",
            "fileName": "../src/features/reference-line.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>global d3: false<br />global d4: false</p>",
                "summary": "<p>global d3: false<br />global d4: false</p>",
                "body": ""
            },
            "ignore": true,
            "code": "'use strict';\n  d4.feature('rowLabels', function(name) {\n    return {\n      accessors: {\n        x: function(d) {\n          var width = (Math.abs(this.x(d[this.x.$key])) + this.x(d[this.x.$key]))/2;\n          return Math.max(this.x(0), width) + 10;\n        },\n\n        y: function(d) {\n          return this.y(d[this.y.$key]) + (this.y.rangeBand() / 2);\n        },\n\n        text: function(d) {\n          return d3.format('').call(this, d[this.x.$key]);\n        }\n      },\n      render: function(scope, data) {\n        this.featuresGroup.append('g').attr('class', name);\n        var group = this.svg.select('.' + name).selectAll('.group')\n          .data(data)\n          .enter().append('g')\n          .attr('class', function(d, i) {\n            return 'series' + i + ' ' + this.x.$key;\n          }.bind(this));\n\n        var text = group.selectAll('text')\n          .data(function(d) {\n            return d.values;\n          }.bind(this));\n        text.exit().remove();\n        text.enter().append('text')\n          .text(scope.accessors.text.bind(this))\n          .attr('class', 'column-label')\n          .attr('y', scope.accessors.y.bind(this))\n          .attr('x', scope.accessors.x.bind(this));\n        return text;\n      }\n    };\n  });\n}).call(this);",
            "fileName": "../src/features/row-labels.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>global d3: false<br />global d4: false</p>",
                "summary": "<p>global d3: false<br />global d4: false</p>",
                "body": ""
            },
            "ignore": true,
            "code": "'use strict';\n  d4.feature('rowSeries', function(name) {\n    var sign = function(val){\n      return (val > 0) ? 'positive' : 'negative';\n    };\n\n    return {\n      accessors: {\n        x: function(d) {\n          var xVal = d[this.x.$key] - Math.max(0, d[this.x.$key]);\n          return this.x(xVal);\n        },\n\n        y: function(d) {\n          return this.y(d[this.y.$key]);\n        },\n\n        width: function(d) {\n          return Math.abs(this.x(d[this.x.$key]) - this.x(0));\n        },\n\n        height: function() {\n          return this.y.rangeBand();\n        },\n\n        classes: function(d,i) {\n          return 'bar fill item'+ i + ' ' + sign(d.y) + ' ' + d[this.x.$key];\n        }\n      },\n      render: function(scope, data) {\n        this.featuresGroup.append('g').attr('class', name);\n        var group = this.svg.select('.' + name).selectAll('.group')\n          .data(data)\n          .enter().append('g')\n          .attr('class', function(d,i) {\n            return 'series'+ i + ' ' +  this.y.$key;\n          }.bind(this));\n\n        var rect = group.selectAll('rect')\n          .data(function(d) {\n            return d.values;\n          }.bind(this));\n\n        rect.enter().append('rect')\n          .attr('class', scope.accessors.classes.bind(this))\n          .attr('x', scope.accessors.x.bind(this))\n          .attr('y', scope.accessors.y.bind(this))\n          .attr('width', scope.accessors.width.bind(this))\n          .attr('height', scope.accessors.height.bind(this));\n        return rect;\n      }\n    };\n  });\n}).call(this);",
            "fileName": "../src/features/row-series.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>global d3: false<br />global d4: false</p>",
                "summary": "<p>global d3: false<br />global d4: false</p>",
                "body": ""
            },
            "ignore": true,
            "fileName": "../src/features/stacked-column-connectors.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>Column connectors helpful when displaying a stacked column chart.<br />    A connector will not connect positve and negative columns. This is because<br />    in a stacked column a negative column may move many series below its previous<br />    location. This creates a messy collection of crisscrossing lines.</p>",
                "summary": "<p>Column connectors helpful when displaying a stacked column chart.<br />    A connector will not connect positve and negative columns. This is because<br />    in a stacked column a negative column may move many series below its previous<br />    location. This creates a messy collection of crisscrossing lines.</p>",
                "body": ""
            },
            "ignore": true,
            "code": "'use strict';\n  d4.feature('stackedColumnConnectors', function(name) {\n\n    return {\n      accessors: {\n        x1: function(d) {\n          var width = 0;\n          var xVal = (d.y0 + d.y) - Math.max(0, d.y);\n          if(d.y > 0){\n            width = Math.abs(this.x(d.y0) - this.x(d.y0 + d.y));\n          }\n          return this.x(xVal) + width;\n\n        },\n\n        y1: function(d) {\n          return this.y(d[this.y.$key]);\n        },\n\n        span: function(){\n          return this.y.rangeBand();\n        },\n\n        classes : function(d, i){\n          return 'series' +i;\n        }\n      },\n\n      render: function(scope) {\n        this.featuresGroup.append('g').attr('class', name);\n        var lines = this.svg.select('.' + name).selectAll('.' + name).data(function(d) {\n          return d.map(function(o) {\n            return o.values[0];\n          });\n        }.bind(this));\n        lines.enter().append('line');\n        lines.exit().remove();\n        lines\n        .attr('class', scope.accessors.classes.bind(this))\n        .attr('x1', function() {\n          // if(i === 0){\n          //   return 0;\n          // }\n          // return scope.accessors.x1.bind(this)(data[i - 1].values[0]);\n        }.bind(this))\n\n        .attr('y1', function() {\n          // if(i === 0){\n          //   return 0;\n          // }\n          // return scope.accessors.y1.bind(this)(data[i - 1].values[0]);\n        }.bind(this))\n\n        .attr('x2', function() {\n          // if(i === 0){\n          //   return 0;\n          // }\n          // return scope.accessors.x1.bind(this)(data[i - 1].values[0]);\n        }.bind(this))\n\n        .attr('y2', function() {\n          // if(i === 0){\n          //   return 0;\n          // }\n          // return scope.accessors.y1.bind(this)(d) + scope.accessors.span.bind(this)(d);\n        }.bind(this));\n\n        return lines;\n      }\n    };\n  });\n}).call(this);",
            "fileName": "../src/features/stacked-column-connectors.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>global d3: false<br />global d4: false</p>",
                "summary": "<p>global d3: false<br />global d4: false</p>",
                "body": ""
            },
            "ignore": true,
            "code": "'use strict';\n  d4.feature('stackedColumnLabels', function(name) {\n    var sign = function(val) {\n      return val > 0 ? 'positive' : 'negative';\n    };\n\n    return {\n      accessors: {\n        x: function(d) {\n          return this.x(d[this.x.$key]) + (this.x.rangeBand() / 2);\n        },\n\n        y: function(d) {\n          if(typeof d.y0 !== 'undefined'){\n            var halfHeight = Math.abs(this.y(d.y0) - this.y(d.y0 + d.y)) / 2;\n            var yVal = d.y0 + d.y;\n            return (yVal < 0 ? this.y(d.y0) : this.y(yVal)) + halfHeight;\n          } else {\n            var height = Math.abs(this.y(d[this.y.$key]) - this.y(0));\n            return (d[this.y.$key] < 0 ? this.y(d[this.y.$key]) - height : this.y(d[this.y.$key])) - 5;\n          }\n        },\n\n        text: function(d) {\n          if(typeof d.y0 !== 'undefined'){\n            if(Math.abs(this.y(d.y0) - this.y(d.y0 + d.y)) > 20) {\n              return d3.format('').call(this, d[this.valueKey]);\n            }\n          } else {\n            return d3.format('').call(this, d[this.valueKey]);\n          }\n        }\n      },\n      render: function(scope, data) {\n        this.featuresGroup.append('g').attr('class', name);\n        var group = this.svg.select('.' + name).selectAll('.group')\n          .data(data)\n          .enter().append('g')\n          .attr('class', function(d, i) {\n            return 'series' + i + ' '+ sign(d.y) + ' ' + this.x.$key;\n          }.bind(this));\n\n        var text = group.selectAll('text')\n          .data(function(d) {\n            return d.values;\n          }.bind(this));\n        text.exit().remove();\n        text.enter().append('text')\n          .text(scope.accessors.text.bind(this))\n          .attr('class', 'column-label')\n          .attr('y', scope.accessors.y.bind(this))\n          .attr('x', scope.accessors.x.bind(this));\n        return text;\n      }\n    };\n  });\n}).call(this);",
            "fileName": "../src/features/stacked-column-labels.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>global d3: false<br />global d4: false</p>",
                "summary": "<p>global d3: false<br />global d4: false</p>",
                "body": ""
            },
            "ignore": true,
            "code": "'use strict';\n  d4.feature('stackedColumnSeries', function(name) {\n    var sign = function(val){\n      return (val > 0) ? 'positive' : 'negative';\n    };\n\n    return {\n      accessors: {\n        x: function(d) {\n          return this.x(d[this.x.$key]);\n        },\n\n        y: function(d) {\n          if(d.y0){\n            var yVal = d.y0 + d.y;\n            return  yVal < 0 ? this.y(d.y0) : this.y(yVal);\n          } else {\n            return d[this.y.$key] < 0 ? this.y(0) : this.y(d[this.y.$key]);\n          }\n        },\n\n        width: function() {\n          return this.x.rangeBand();\n        },\n\n        height: function(d) {\n          if(d.y0){\n            return Math.abs(this.y(d.y0) - this.y(d.y0 + d.y));\n          }else {\n            return Math.abs(this.y(d[this.y.$key]) - this.y(0));\n          }\n        },\n\n        classes: function(d,i) {\n          return 'bar fill item'+ i + ' ' + sign(d.y) + ' ' + d[this.y.$key];\n        }\n      },\n      render: function(scope, data) {\n        this.featuresGroup.append('g').attr('class', name);\n        var group = this.svg.select('.' + name).selectAll('.group')\n          .data(data)\n          .enter().append('g')\n          .attr('class', function(d,i) {\n            return 'series'+ i + ' ' +  this.y.$key;\n          }.bind(this));\n\n        var rect = group.selectAll('rect')\n          .data(function(d) {\n            return d.values;\n          }.bind(this));\n\n        rect.enter().append('rect')\n          .attr('class', scope.accessors.classes.bind(this))\n          .attr('x', scope.accessors.x.bind(this))\n          .attr('y', scope.accessors.y.bind(this))\n          .attr('width', scope.accessors.width.bind(this))\n          .attr('height', scope.accessors.height.bind(this));\n        return rect;\n      }\n    };\n  });\n}).call(this);",
            "fileName": "../src/features/stacked-column-series.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>global d3: false<br />global d4: false</p>",
                "summary": "<p>global d3: false<br />global d4: false</p>",
                "body": ""
            },
            "ignore": true,
            "code": "'use strict';\n  d4.feature('trendLine', function(name) {\n    return {\n      accessors: {\n        x1: function() {\n          return this.x(0);\n        },\n\n        x2: function() {\n          return this.x(this.width);\n        },\n\n        y1: function() {\n          return this.y(0);\n        },\n\n        y2: function() {\n          return this.y(this.height);\n        },\n\n        text: function(d) {\n          return d3.format('').call(this, d[1]);\n        },\n\n        textX: function() {\n          return this.x(this.width);\n        },\n\n        textY: function(){\n          return this.x(this.height);\n        }\n      },\n      render: function(scope) {\n        var defs = this.svg.select('defs');\n\n        defs.append('marker')\n          .attr('id', name + '-start')\n          .attr('viewBox', '0 0 10 10')\n          .attr('refX', 10)\n          .attr('refY', 5)\n          .attr('markerWidth', -6)\n          .attr('markerHeight', 6)\n          .attr('orient', 'auto')\n          .append('path')\n          .attr('d', 'M 0 0 L 10 5 L 0 10 z');\n\n        this.featuresGroup.append('g').attr('class', name);\n        var trendLine = this.svg.select('.' + name)\n          .append('line')\n          .attr('class', 'line')\n          .attr('x1', scope.accessors.x1.bind(this))\n          .attr('x2', scope.accessors.x2.bind(this))\n          .attr('y1', scope.accessors.y1.bind(this))\n          .attr('y2', scope.accessors.y2.bind(this))\n          .attr('marker-end', 'url(#' + name + '-start)');\n\n        this.svg.select('.' + name)\n          .append('text')\n          .attr('class', 'trendLine-label')\n          .text(scope.accessors.text.bind(this))\n          .attr('x', scope.accessors.textX.bind(this))\n          .attr('y', scope.accessors.textY.bind(this));\n        return trendLine;\n      }\n    };\n  });\n}).call(this);",
            "fileName": "../src/features/trend-line.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>global d3: false<br />global d4: false</p>",
                "summary": "<p>global d3: false<br />global d4: false</p>",
                "body": ""
            },
            "ignore": true,
            "fileName": "../src/features/waterfall-connectors.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>Waterfall connectors are orthogonal series connectors which visually join<br />column series together by spanning the top or bottom of adjacent columns.</p>\n\n<p>When using this feature in charts other than waterfall, be aware that the<br />mixin expects an accessor property for <code>orientation</code>, which it uses to render<br />the direction of the lines.</p>\n\n<h5>Accessors</h5>\n\n<p><code>x</code> - Used in placement of the connector lines.<br /><code>y</code> - Used in placement of the connector lines.<br /><code>span</code> - calculates the length of the connector line<br /><code>classes</code> - applies the class to the connector lines.</p>",
                "summary": "<p>Waterfall connectors are orthogonal series connectors which visually join<br />column series together by spanning the top or bottom of adjacent columns.</p>",
                "body": "<p>When using this feature in charts other than waterfall, be aware that the<br />mixin expects an accessor property for <code>orientation</code>, which it uses to render<br />the direction of the lines.</p>\n\n<h5>Accessors</h5>\n\n<p><code>x</code> - Used in placement of the connector lines.<br /><code>y</code> - Used in placement of the connector lines.<br /><code>span</code> - calculates the length of the connector line<br /><code>classes</code> - applies the class to the connector lines.</p>"
            },
            "ignore": false,
            "code": "d4.feature('waterfallConnectors', function(name) {\n    return {\n      accessors: {\n        x: function(d) {\n          if(this.orientation() === 'horizontal'){\n            var width = 0;\n            var xVal = (d.y0 + d.y) - Math.max(0, d.y);\n            if(d.y > 0){\n              width = Math.abs(this.x(d.y0) - this.x(d.y0 + d.y));\n            }\n            return this.x(xVal) + width;\n          } else {\n            return this.x(d[this.x.$key]);\n          }\n        },\n\n        y: function(d) {\n          if(this.orientation() === 'horizontal'){\n            return this.y(d[this.y.$key]);\n          } else {\n            return this.y(d.y0 + d.y);\n          }\n        },\n\n        span: function(){\n          if(this.orientation() === 'horizontal'){\n            return this.y.rangeBand();\n          } else {\n            return this.x.rangeBand();\n          }\n        },\n\n        classes : function(d, i){\n          return 'series' +i;\n        }\n      },\n\n      render: function(scope, data) {\n        this.featuresGroup.append('g').attr('class', name);\n        var lines = this.svg.select('.' + name).selectAll('.' + name).data(function(d) {\n          return d.map(function(o) {\n            return o.values[0];\n          });\n        }.bind(this));\n        lines.enter().append('line');\n        lines.exit().remove();\n        lines\n        .attr('class', scope.accessors.classes.bind(this))\n        .attr('x1', function(d, i) {\n          if(i === 0){\n            return 0;\n          }\n          return scope.accessors.x.bind(this)(data[i - 1].values[0]);\n        }.bind(this))\n\n        .attr('y1', function(d, i) {\n          if(i === 0){\n            return 0;\n          }\n          return scope.accessors.y.bind(this)(data[i - 1].values[0]);\n        }.bind(this))\n\n        .attr('x2', function(d, i) {\n          if(i === 0){\n            return 0;\n          }\n          if(this.orientation() === 'vertical') {\n            return scope.accessors.x.bind(this)(d) + scope.accessors.span.bind(this)();\n          } else {\n            return scope.accessors.x.bind(this)(data[i - 1].values[0]);\n          }\n        }.bind(this))\n\n        .attr('y2', function(d, i) {\n          if(i === 0){\n            return 0;\n          }\n          if(this.orientation() === 'vertical') {\n            return scope.accessors.y.bind(this)(data[i - 1].values[0]);\n          }else {\n            return scope.accessors.y.bind(this)(d) + scope.accessors.span.bind(this)(d);\n          }\n        }.bind(this));\n\n        return lines;\n      }\n    };\n  });\n}).call(this);",
            "fileName": "../src/features/waterfall-connectors.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>global d3: false<br />global d4: false</p>",
                "summary": "<p>global d3: false<br />global d4: false</p>",
                "body": ""
            },
            "ignore": true,
            "code": "'use strict';\n  d4.feature('xAxis', function(name) {\n    return {\n      accessors: {\n        format: function(xAxis) {\n          return xAxis.orient('bottom').tickSize(0);\n        }\n      },\n      render: function(scope) {\n        var xAxis = d3.svg.axis().scale(this.x);\n        var formattedAxis = scope.accessors.format.bind(this)(xAxis);\n        this.featuresGroup.append('g').attr('class', 'x axis '+ name)\n          .attr('transform', 'translate(0,' + (this.height - this.margin.top - this.margin.bottom) + ')')\n          .call(formattedAxis);\n\n      }\n    };\n  });\n}).call(this);",
            "fileName": "../src/features/x-axis.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>global d3: false<br />global d4: false</p>",
                "summary": "<p>global d3: false<br />global d4: false</p>",
                "body": ""
            },
            "ignore": true,
            "code": "'use strict';\n  d4.feature('yAxis', function(name) {\n\n    // FIXME: This should be a util function\n    // Extracted from: http://bl.ocks.org/mbostock/7555321\n    var wrap = function(text, width) {\n      text.each(function() {\n        var text = d3.select(this),\n            words = text.text().split(/\\s+/).reverse(),\n            word,\n            line = [],\n            lineNumber = 0,\n            lineHeight = 1.1, // ems\n            x = text.attr('x'),\n            y = text.attr('y'),\n            dy = parseFloat(text.attr('dy')),\n            tspan = text.text(null).append('tspan').attr('x', x).attr('y', y).attr('dy', dy + 'em');\n        word = words.pop();\n        while (word) {\n          line.push(word);\n          tspan.text(line.join(' '));\n          if (tspan.node().getComputedTextLength() > width - Math.abs(x)) {\n            line.pop();\n            tspan.text(line.join(' '));\n            line = [word];\n            tspan = text.append('tspan').attr('x', x).attr('y', y).attr('dy', ++lineNumber * lineHeight + dy + 'em').text(word);\n          }\n          word = words.pop();\n        }\n      });\n    };\n\n    return {\n      accessors: {\n        format: function(yAxis) {\n          return yAxis.orient('left').tickSize(0);\n        }\n      },\n      render: function(scope) {\n        var yAxis = d3.svg.axis().scale(this.y);\n        var formattedAxis = scope.accessors.format.bind(this)(yAxis);\n        this.featuresGroup.append('g').attr('class', 'y axis ' + name)\n          .attr('transform', 'translate(0,0)')\n          .call(formattedAxis)\n          .selectAll('.tick text')\n          .call(wrap, this.margin.left);\n      }\n    };\n  });\n}).call(this);",
            "fileName": "../src/features/y-axis.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>global d3: false</p>",
                "summary": "<p>global d3: false</p>",
                "body": ""
            },
            "ignore": true,
            "fileName": "../src/parsers/nested-group.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>global d4: false</p>",
                "summary": "<p>global d4: false</p>",
                "body": ""
            },
            "ignore": true,
            "code": "'use strict';",
            "fileName": "../src/parsers/nested-group.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>The nested group parser is useful for grouped column charts where multiple<br />data items need to appear relative to the axis value, for example grouped<br />column charts or multi-series line charts.</p>\n\n<pre><code>_____________________\n|           _        |\n|   _ _    | |_      |\n|  | | |   | | |     |\n----------------------\n</code></pre>\n\n<p>This module makes use of the d3's \"nest\" data structure layout</p>\n\n<p><a href='https://github.com/mbostock/d3/wiki/Arrays#-nest'>https://github.com/mbostock/d3/wiki/Arrays#-nest</a></p>\n\n<h4>Approach</h4>\n\n<p>Just like D3, this parser uses a chaining declaritiave style to build up<br />the necessary prerequistes to create the waterfall data. Here is a simple<br />example. Given a data item structure like this: {\"category\" : \"Category One\", \"value\" : 23 }</p>\n\n<pre><code>var parser = d4.parsers.nestedGroup()\n    .x('category')\n    .y('value')\n    .value('value');\n\nvar groupedColumnData = parser(data);\n</code></pre>\n\n<p>Keep reading for more information on these various accessor functions.</p>\n\n<h4>Accessor Methods</h4>\n\n<p><code>x</code> - A function which returns a key to access the x values in the data array<br /><code>y</code> - A function which returns a key to access the y values in the data array<br /><code>value</code> - A function which returns a key to access the values in the data array.<br /><code>data</code> - An array of objects with their dimensions specified like this:</p>\n\n<pre><code>var data = [\n{\"year\" : \"2010\", \"category\" : \"Category One\", \"value\" : 23 },\n{\"year\" : \"2010\", \"category\" : \"Category Two\", \"value\" : 55 },\n{\"year\" : \"2010\", \"category\" : \"Category Three\", \"value\" : -10 },\n{\"year\" : \"2010\", \"category\" : \"Category Four\", \"value\" : 5 }]\n</code></pre>",
                "summary": "<p>The nested group parser is useful for grouped column charts where multiple<br />data items need to appear relative to the axis value, for example grouped<br />column charts or multi-series line charts.</p>",
                "body": "<pre><code>_____________________\n|           _        |\n|   _ _    | |_      |\n|  | | |   | | |     |\n----------------------\n</code></pre>\n\n<p>This module makes use of the d3's \"nest\" data structure layout</p>\n\n<p><a href='https://github.com/mbostock/d3/wiki/Arrays#-nest'>https://github.com/mbostock/d3/wiki/Arrays#-nest</a></p>\n\n<h4>Approach</h4>\n\n<p>Just like D3, this parser uses a chaining declaritiave style to build up<br />the necessary prerequistes to create the waterfall data. Here is a simple<br />example. Given a data item structure like this: {\"category\" : \"Category One\", \"value\" : 23 }</p>\n\n<pre><code>var parser = d4.parsers.nestedGroup()\n    .x('category')\n    .y('value')\n    .value('value');\n\nvar groupedColumnData = parser(data);\n</code></pre>\n\n<p>Keep reading for more information on these various accessor functions.</p>\n\n<h4>Accessor Methods</h4>\n\n<p><code>x</code> - A function which returns a key to access the x values in the data array<br /><code>y</code> - A function which returns a key to access the y values in the data array<br /><code>value</code> - A function which returns a key to access the values in the data array.<br /><code>data</code> - An array of objects with their dimensions specified like this:</p>\n\n<pre><code>var data = [\n{\"year\" : \"2010\", \"category\" : \"Category One\", \"value\" : 23 },\n{\"year\" : \"2010\", \"category\" : \"Category Two\", \"value\" : 55 },\n{\"year\" : \"2010\", \"category\" : \"Category Three\", \"value\" : -10 },\n{\"year\" : \"2010\", \"category\" : \"Category Four\", \"value\" : 5 }]\n</code></pre>"
            },
            "ignore": false,
            "code": "d4.parser('nestedGroup', function nestedGroup() {\n\n    var opts = {\n      x: {\n        key: 'x',\n        values: []\n      },\n      y: {\n        key: 'y',\n        values: []\n      },\n      value: {\n        key: 'value',\n        values: []\n      },\n      data: []\n    };\n    opts.nestKey = function(){\n      return opts.x.key;\n    };\n\n    var findValues = function(dimensions, items) {\n      ['x', 'y', 'value'].forEach(function(k) {\n        var layers = items.map(function(d) {\n          return d[dimensions[k].key];\n        });\n        opts[k].values = d3.set(layers).values();\n      });\n    };\n\n    var nestByDimension = function(key, valueKey, items) {\n      var nest = d3.nest()\n        .key(function(d) {\n          return d[key];\n        });\n      return nest.entries(items);\n    };\n\n    var setDimension = function(dim, funct) {\n      opts[dim].key = d4.functor(funct)();\n    };\n\n    var parser = function(data) {\n      if (data) {\n        d4.extend(opts.data, data);\n      }\n\n      findValues(opts, opts.data);\n      opts.data = nestByDimension(opts.nestKey(), opts.value.key, opts.data);\n\n      return opts;\n    };\n\n    parser.nestKey = function(funct) {\n      opts.nestKey = d4.functor(funct).bind(opts);\n      return parser;\n    };\n\n    parser.x = function(funct) {\n      setDimension.bind(opts)('x', funct);\n      return parser;\n    };\n\n    parser.y = function(funct) {\n      setDimension.bind(opts)('y', funct);\n      return parser;\n    };\n\n    parser.value = function(funct) {\n      setDimension.bind(opts)('value', funct);\n      return parser;\n    };\n\n    return parser;\n  });\n}).call(this);",
            "fileName": "../src/parsers/nested-group.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>global d3: false</p>",
                "summary": "<p>global d3: false</p>",
                "body": ""
            },
            "ignore": true,
            "fileName": "../src/parsers/nested-stack.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>global d4: false</p>",
                "summary": "<p>global d4: false</p>",
                "body": ""
            },
            "ignore": true,
            "code": "'use strict';",
            "fileName": "../src/parsers/nested-stack.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>The nested stack parser is useful for charts which take a data series<br />  and wants to sort them across a dimension and then display the results.<br />  The most common usecase would be a stacked column chart like this:</p>\n\n<pre><code>_____________________\n|    _               |\n|   | |   _          |\n|   |-|  | |   _     |\n|   |-|  |-|  |-|    |\n|   | |  |-|  |-|    |\n----------------------\n</code></pre>\n\n<p>This module makes use of the d3's \"nest\" data structure, and \"stack\" layout</p>\n\n<p><a href='https://github.com/mbostock/d3/wiki/Arrays#-nest'>https://github.com/mbostock/d3/wiki/Arrays#-nest</a><br /><a href='https://github.com/mbostock/d3/wiki/Stack-Layout'>https://github.com/mbostock/d3/wiki/Stack-Layout</a></p>\n\n<h4>Approach</h4>\n\n<p>Just like D3, this parser uses a chaining declaritiave style to build up<br />the necessary prerequistes to create the stacked data. Here is a simple<br />example:</p>\n\n<pre><code>    var parser = d4.parsers.nestedStack()\n        .x(function() {\n          return 'title';\n        })\n        .y(function(){\n          return 'group';\n        })\n        .value(function() {\n          return 'values';\n        });\n\n    var stackedData = parser(data);\n</code></pre>\n\n<p>Keep reading for more information on these various accessor functions.</p>\n\n<h5>Benefits</h5>\n\n<ul>\n<li>Supports negative and positive stacked data series.</li>\n</ul>\n\n<h5>Limitations</h5>\n\n<ul>\n<li>The parser expects the stack will occur on the yAxis, which means it is only suitable for column charts presently.</li>\n</ul>\n\n<h5>Accessor Methods</h5>\n\n<p><code>x</code> : - function which returns a key to access the x values in the data array<br /><code>y</code> : - function which returns a key to access the y values in the data array<br /><code>value</code> : - function which returns a key to access the values in the data array.<br /><code>data</code> : array - An array of objects with their dimensions specified like this:</p>\n\n<pre><code>var data = [{ \"title\": \"3 Years\", \"group\" : \"one\", \"value\": 30 },\n            { \"title\": \"3 Years\", \"group\" : \"two\", \"value\": 20 },\n            { \"title\": \"3 Years\", \"group\" : \"three\", \"value\": 10 },\n            { \"title\": \"5 Years\", \"group\" : \"one\",  \"value\": 3 },\n            { \"title\": \"5 Years\", \"group\" : \"two\", \"value\": 2 },\n            { \"title\": \"5 Years\", \"group\" : \"three\", \"value\": 1 }]\n</code></pre>\n\n<h5>Example Usage</h5>\n\n<p>Given the example data and dimension variables above you can use this module<br />in the following way:</p>\n\n<pre><code>var parser = d4.parsers.nestedStack()\n.x(function() {\n  return 'title';\n})\n.y(function(){\n  return 'group';\n})\n.value(function() {\n  return 'value';\n})\n.call(data);\n</code></pre>\n\n<p>The <code>parser</code> variable will now be an object containing the following structure:</p>\n\n<pre><code>{\n  data: Array\n  value: {\n    key: string,\n    values: Array\n  },\n  x: {\n    key: string,\n    values: Array\n  },\n  y: {\n    key: string,\n    values: Array\n  }\n}\n</code></pre>",
                "summary": "<p>The nested stack parser is useful for charts which take a data series<br />  and wants to sort them across a dimension and then display the results.<br />  The most common usecase would be a stacked column chart like this:</p>",
                "body": "<pre><code>_____________________\n|    _               |\n|   | |   _          |\n|   |-|  | |   _     |\n|   |-|  |-|  |-|    |\n|   | |  |-|  |-|    |\n----------------------\n</code></pre>\n\n<p>This module makes use of the d3's \"nest\" data structure, and \"stack\" layout</p>\n\n<p><a href='https://github.com/mbostock/d3/wiki/Arrays#-nest'>https://github.com/mbostock/d3/wiki/Arrays#-nest</a><br /><a href='https://github.com/mbostock/d3/wiki/Stack-Layout'>https://github.com/mbostock/d3/wiki/Stack-Layout</a></p>\n\n<h4>Approach</h4>\n\n<p>Just like D3, this parser uses a chaining declaritiave style to build up<br />the necessary prerequistes to create the stacked data. Here is a simple<br />example:</p>\n\n<pre><code>    var parser = d4.parsers.nestedStack()\n        .x(function() {\n          return 'title';\n        })\n        .y(function(){\n          return 'group';\n        })\n        .value(function() {\n          return 'values';\n        });\n\n    var stackedData = parser(data);\n</code></pre>\n\n<p>Keep reading for more information on these various accessor functions.</p>\n\n<h5>Benefits</h5>\n\n<ul>\n<li>Supports negative and positive stacked data series.</li>\n</ul>\n\n<h5>Limitations</h5>\n\n<ul>\n<li>The parser expects the stack will occur on the yAxis, which means it is only suitable for column charts presently.</li>\n</ul>\n\n<h5>Accessor Methods</h5>\n\n<p><code>x</code> : - function which returns a key to access the x values in the data array<br /><code>y</code> : - function which returns a key to access the y values in the data array<br /><code>value</code> : - function which returns a key to access the values in the data array.<br /><code>data</code> : array - An array of objects with their dimensions specified like this:</p>\n\n<pre><code>var data = [{ \"title\": \"3 Years\", \"group\" : \"one\", \"value\": 30 },\n            { \"title\": \"3 Years\", \"group\" : \"two\", \"value\": 20 },\n            { \"title\": \"3 Years\", \"group\" : \"three\", \"value\": 10 },\n            { \"title\": \"5 Years\", \"group\" : \"one\",  \"value\": 3 },\n            { \"title\": \"5 Years\", \"group\" : \"two\", \"value\": 2 },\n            { \"title\": \"5 Years\", \"group\" : \"three\", \"value\": 1 }]\n</code></pre>\n\n<h5>Example Usage</h5>\n\n<p>Given the example data and dimension variables above you can use this module<br />in the following way:</p>\n\n<pre><code>var parser = d4.parsers.nestedStack()\n.x(function() {\n  return 'title';\n})\n.y(function(){\n  return 'group';\n})\n.value(function() {\n  return 'value';\n})\n.call(data);\n</code></pre>\n\n<p>The <code>parser</code> variable will now be an object containing the following structure:</p>\n\n<pre><code>{\n  data: Array\n  value: {\n    key: string,\n    values: Array\n  },\n  x: {\n    key: string,\n    values: Array\n  },\n  y: {\n    key: string,\n    values: Array\n  }\n}\n</code></pre>"
            },
            "ignore": false,
            "code": "d4.parser('nestedStack', function nestedStack() {\n\n    var opts = {\n      x: {\n        key: 'x',\n        values: []\n      },\n      y: {\n        key: 'y',\n        values: []\n      },\n      value: {\n        key: 'value',\n        values: []\n      },\n      data: []\n    };\n\n    var findValues = function(dimensions, items) {\n      ['x', 'y', 'value'].forEach(function(k) {\n        var layers = items.map(function(d) {\n          return d[dimensions[k].key];\n        });\n        opts[k].values = d3.set(layers).values();\n      });\n    };\n\n    var nestByDimension = function(stackKey, valueKey, items) {\n      var nest = d3.nest()\n        .key(function(d) {\n          return d[stackKey];\n        });\n      return nest.entries(items);\n    };\n\n    // By default D3 doesn't handle stacks with negative values very well, we\n    // need to calulate or our y and y0 values for each group.\n    var stackByDimension = function(key, items) {\n      var offsets = {};\n\n      var stack = d3.layout.stack()\n        .values(function(d) {\n          return d.values;\n        })\n        .x(function(d) {\n          return d[key];\n        })\n        .y(function(d) {\n          return +d[opts.value.key];\n        })\n        .out(function(d, y0, y) {\n          d.y = y;\n          if (d.y >= 0) {\n            d.y0 = offsets[d[key] + 'Pos'] = offsets[d[key] + 'Pos'] || 0;\n            offsets[d[key] + 'Pos'] += y;\n          } else {\n            d.y0 = offsets[d[key] + 'Neg'] = offsets[d[key] + 'Neg'] || 0;\n            offsets[d[key] + 'Neg'] -= Math.abs(y);\n          }\n        });\n      stack(items.reverse());\n    };\n\n    var setDimension = function(dim, funct) {\n      opts[dim].key = d4.functor(funct)();\n    };\n\n    var parser = function(data) {\n      if (data) {\n        d4.extend(opts.data, data);\n      }\n\n      findValues(opts, opts.data);\n      opts.data = nestByDimension(opts.y.key, opts.value.key, opts.data);\n\n      stackByDimension(opts.x.key, opts.data);\n      return opts;\n    };\n\n    parser.x = function(funct) {\n      setDimension.bind(opts)('x', funct);\n      return parser;\n    };\n\n    parser.y = function(funct) {\n      setDimension.bind(opts)('y', funct);\n      return parser;\n    };\n\n    parser.value = function(funct) {\n      setDimension.bind(opts)('value', funct);\n      return parser;\n    };\n\n    return parser;\n  });\n}).call(this);",
            "fileName": "../src/parsers/nested-stack.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>global d3: false</p>",
                "summary": "<p>global d3: false</p>",
                "body": ""
            },
            "ignore": true,
            "fileName": "../src/parsers/waterfall.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>global d4: false</p>",
                "summary": "<p>global d4: false</p>",
                "body": ""
            },
            "ignore": true,
            "code": "'use strict';",
            "fileName": "../src/parsers/waterfall.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>The waterfall parser is useful for waterfall charts where data items need to account<br />    for the position of earlier values:</p>\n\n<pre><code>_____________________\n|   _        _______ |\n|  |_|___   | |  | | |\n|      |_|__|_|  | | |\n|                |_| |\n----------------------\n\nThis module makes use of the d3's \"nest\" data structure, and \"stack\" layout\n<a href='https://github.com/mbostock/d3/wiki/Arrays#-nest'>https://github.com/mbostock/d3/wiki/Arrays#-nest</a>\n<a href='https://github.com/mbostock/d3/wiki/Stack-Layout'>https://github.com/mbostock/d3/wiki/Stack-Layout</a>\n\n\nApproach:\nJust like D3, this parser uses a chaining declaritiave style to build up\nthe necessary prerequistes to create the waterfall data. Here is a simple\nexample. Given a data item structure like this: {\"category\" : \"Category One\", \"value\" : 23 }\n\nvar parser = d4.parsers.waterfall()\n    .x(function() {\n      return 'category';\n    })\n    .y(function(){\n      return 'value';\n    })\n    .value(function() {\n      return 'value';\n    });\n\nvar waterfallData = parser(data);\n\nKeep reading for more information on these various accessor functions.\n\nBenefits:\n</code></pre>\n\n<p>Supports horizontal or vertical waterfalls<br />Supports totaling series using a special \"e\" value in a data item.</p>\n\n<pre><code>Limitations:\n</code></pre>\n\n<p>Does not support stacked waterfalls.</p>\n\n<pre><code>Accessor Methods:\n</code></pre>\n\n<p>x : - function which returns a key to access the x values in the data array<br />y : - function which returns a key to access the y values in the data array<br />value : - function which returns a key to access the values in the data array.<br />data : array - An array of objects with their dimensions specified<br />      like this:</p>\n\n<pre><code>  var data = [\n  {\"category\" : \"Category One\", \"value\" : 23 },\n  {\"category\" : \"Category Two\", \"value\" : 55 },\n  {\"category\" : \"Category Three\", \"value\" : -10 },\n  {\"category\" : \"Category Four\", \"value\" : 5 },\n  {\"category\" : \"Category Five\", \"value\" : \"e\" }]\n\nSPECIAL NOTE:\nWaterfalls charts typically have the ability to display subtotals at any point.\nIn order to use this feature simply set the value of your subtotal column to \"e.\"\n\nExample Usage:\nGiven the example data and dimension variables above you can use this module\nin the following way:\n\nvar parser = d4.parsers.nestedStack()\n.dimensions(dimensions)\n.call(data);\n\nThe `parser` variable will now be an object containing the following structure:\n{\n  data: Array\n  value: {\n    key: string,\n    values: Array\n  },\n  x: {\n    key: string,\n    values: Array\n  },\n  y: {\n    key: string,\n    values: Array\n  }\n}\n\nTaking these attributes one-by-one:\n</code></pre>\n\n<p>data - is an array of items stacked by D3<br />value - an object with a key representing the value accessor and an array of values<br />x - an object with a key representing the x accessor and an array of values<br />y - an object with a key representing the y accessor and an array of values</p>",
                "summary": "<p>The waterfall parser is useful for waterfall charts where data items need to account<br />    for the position of earlier values:</p>",
                "body": "<pre><code>_____________________\n|   _        _______ |\n|  |_|___   | |  | | |\n|      |_|__|_|  | | |\n|                |_| |\n----------------------\n\nThis module makes use of the d3's \"nest\" data structure, and \"stack\" layout\n<a href='https://github.com/mbostock/d3/wiki/Arrays#-nest'>https://github.com/mbostock/d3/wiki/Arrays#-nest</a>\n<a href='https://github.com/mbostock/d3/wiki/Stack-Layout'>https://github.com/mbostock/d3/wiki/Stack-Layout</a>\n\n\nApproach:\nJust like D3, this parser uses a chaining declaritiave style to build up\nthe necessary prerequistes to create the waterfall data. Here is a simple\nexample. Given a data item structure like this: {\"category\" : \"Category One\", \"value\" : 23 }\n\nvar parser = d4.parsers.waterfall()\n    .x(function() {\n      return 'category';\n    })\n    .y(function(){\n      return 'value';\n    })\n    .value(function() {\n      return 'value';\n    });\n\nvar waterfallData = parser(data);\n\nKeep reading for more information on these various accessor functions.\n\nBenefits:\n</code></pre>\n\n<p>Supports horizontal or vertical waterfalls<br />Supports totaling series using a special \"e\" value in a data item.</p>\n\n<pre><code>Limitations:\n</code></pre>\n\n<p>Does not support stacked waterfalls.</p>\n\n<pre><code>Accessor Methods:\n</code></pre>\n\n<p>x : - function which returns a key to access the x values in the data array<br />y : - function which returns a key to access the y values in the data array<br />value : - function which returns a key to access the values in the data array.<br />data : array - An array of objects with their dimensions specified<br />      like this:</p>\n\n<pre><code>  var data = [\n  {\"category\" : \"Category One\", \"value\" : 23 },\n  {\"category\" : \"Category Two\", \"value\" : 55 },\n  {\"category\" : \"Category Three\", \"value\" : -10 },\n  {\"category\" : \"Category Four\", \"value\" : 5 },\n  {\"category\" : \"Category Five\", \"value\" : \"e\" }]\n\nSPECIAL NOTE:\nWaterfalls charts typically have the ability to display subtotals at any point.\nIn order to use this feature simply set the value of your subtotal column to \"e.\"\n\nExample Usage:\nGiven the example data and dimension variables above you can use this module\nin the following way:\n\nvar parser = d4.parsers.nestedStack()\n.dimensions(dimensions)\n.call(data);\n\nThe `parser` variable will now be an object containing the following structure:\n{\n  data: Array\n  value: {\n    key: string,\n    values: Array\n  },\n  x: {\n    key: string,\n    values: Array\n  },\n  y: {\n    key: string,\n    values: Array\n  }\n}\n\nTaking these attributes one-by-one:\n</code></pre>\n\n<p>data - is an array of items stacked by D3<br />value - an object with a key representing the value accessor and an array of values<br />x - an object with a key representing the x accessor and an array of values<br />y - an object with a key representing the y accessor and an array of values</p>"
            },
            "ignore": false,
            "code": "d4.parser('waterfall', function waterfall() {\n\n    var opts = {\n      x: {\n        key: 'x',\n        values: []\n      },\n      y: {\n        key: 'y',\n        values: []\n      },\n      value: {\n        key: 'value',\n        values: []\n      },\n      data: []\n    };\n    opts.nestKey = function(){\n      return opts.x.key;\n    };\n\n\n    var findValues = function(dimensions, items) {\n      ['x', 'y', 'value'].forEach(function(k) {\n        var layers = items.map(function(d) {\n          return d[dimensions[k].key];\n        });\n        opts[k].values = d3.set(layers).values();\n      });\n    };\n\n    var nestByDimension = function(key, valueKey, items) {\n      var nest = d3.nest()\n        .key(function(d) {\n          return d[key];\n        });\n      return nest.entries(items);\n    };\n\n    var stackByDimension = function(key, items) {\n      var lastOffset = 0;\n      var noNaN = function(num){\n        return isNaN(num) ? 0 : num;\n      };\n      var stack = d3.layout.stack()\n        .values(function(d) {\n          return d.values;\n        })\n        .x(function(d) {\n          return d[key];\n        })\n        .y(function(d) {\n          return +d[opts.value.key];\n        })\n        .out(function(d, y0, y) {\n          if(isNaN(y)){\n            if(isNaN(y0)){\n              y0 = lastOffset;\n            }\n            d.y0 = 0;\n            d.y = y0;\n            d[opts.value.key] = y0;\n            lastOffset = y0;\n          } else {\n            if(isNaN(y0)){\n              d.y0 = lastOffset;\n              lastOffset += y;\n            } else {\n              d.y0 = y0;\n            }\n            d.y = y;\n            d[opts.value.key] = noNaN(d[opts.value.key]);\n          }\n        });\n      stack(items);\n    };\n\n    var setDimension = function(dim, funct) {\n      opts[dim].key = d4.functor(funct)();\n    };\n\n    var parser = function(data) {\n      if (data) {\n        d4.extend(opts.data, data);\n      }\n\n      findValues(opts, opts.data);\n      opts.data = nestByDimension(opts.nestKey(), opts.value.key, opts.data);\n\n      stackByDimension(opts.x.key, opts.data);\n      return opts;\n    };\n\n    parser.nestKey = function(funct) {\n      opts.nestKey = d4.functor(funct).bind(opts);\n      return parser;\n    };\n\n    parser.x = function(funct) {\n      setDimension.bind(opts)('x', funct);\n      return parser;\n    };\n\n    parser.y = function(funct) {\n      setDimension.bind(opts)('y', funct);\n      return parser;\n    };\n\n    parser.value = function(funct) {\n      setDimension.bind(opts)('value', funct);\n      return parser;\n    };\n\n    return parser;\n  });\n}).call(this);",
            "fileName": "../src/parsers/waterfall.js"
        }
    ],
    "mox": [
        {},
        {},
        {},
        {},
        {},
        {},
        {},
        {},
        {
            "params": [
                {
                    "types": [
                        "String"
                    ],
                    "name": "name",
                    "description": "- accessor name for chart."
                },
                {
                    "types": [
                        "Function"
                    ],
                    "name": "funct",
                    "description": "- function which will instantiate the chart."
                }
            ],
            "name": "chart",
            "type": "method",
            "fileName": "../src/base.js",
            "description": {
                "full": "<p>This function allows you to register a reusable chart with d4.</p>",
                "summary": "<p>This function allows you to register a reusable chart with d4.</p>",
                "body": ""
            },
            "returns": "a reference to the chart function"
        },
        {
            "params": [
                {
                    "types": [
                        "String"
                    ],
                    "name": "name",
                    "description": "- accessor name for chart feature."
                },
                {
                    "types": [
                        "Function"
                    ],
                    "name": "funct",
                    "description": "- function which will instantiate the chart feature."
                }
            ],
            "name": "feature",
            "type": "method",
            "fileName": "../src/base.js",
            "description": {
                "full": "<p>This function allows you to register a reusable chart feature with d4.</p>",
                "summary": "<p>This function allows you to register a reusable chart feature with d4.</p>",
                "body": ""
            },
            "returns": "a reference to the chart feature"
        },
        {
            "params": [
                {
                    "types": [
                        "String"
                    ],
                    "name": "name",
                    "description": "- accessor name for chart builder."
                },
                {
                    "types": [
                        "Function"
                    ],
                    "name": "funct",
                    "description": "- function which will instantiate the chart builder."
                }
            ],
            "name": "builder",
            "type": "method",
            "fileName": "../src/base.js",
            "description": {
                "full": "<p>This function allows you to register a reusable chart builder with d4.</p>",
                "summary": "<p>This function allows you to register a reusable chart builder with d4.</p>",
                "body": ""
            },
            "returns": "a reference to the chart builder"
        },
        {
            "params": [
                {
                    "types": [
                        "String"
                    ],
                    "name": "name",
                    "description": "- accessor name for data parser."
                },
                {
                    "types": [
                        "Function"
                    ],
                    "name": "funct",
                    "description": "- function which will instantiate the data parser."
                }
            ],
            "name": "parser",
            "type": "method",
            "fileName": "../src/base.js",
            "description": {
                "full": "<p>This function allows you to register a reusable data parser with d4.</p>",
                "summary": "<p>This function allows you to register a reusable data parser with d4.</p>",
                "body": ""
            },
            "returns": "a reference to the data parser"
        },
        {
            "params": [
                {
                    "types": [
                        "Function"
                    ],
                    "name": "defaultBuilder",
                    "description": "- function which will return a valid builder object when invoked."
                },
                {
                    "types": [
                        "Object"
                    ],
                    "name": "config",
                    "description": "- an object representing chart configuration settings"
                }
            ],
            "name": "baseChart",
            "type": "method",
            "fileName": "../src/base.js",
            "description": {
                "full": "<p>This function creates a d4 chart object. It is only used when creating a<br />new chart factory.</p>\n\n<h5>Examples</h5>\n\n<pre><code>d4.chart('column', function columnChart() {\n    var chart = d4.baseChart({\n      axes: [{\n        key: 'x',\n        scale: 'ordinal'\n      }, {\n        key: 'y',\n        scale: 'linear'\n      }]\n    }, columnChartBuilder);\n    return chart;\n});\n</code></pre>",
                "summary": "<p>This function creates a d4 chart object. It is only used when creating a<br />new chart factory.</p>",
                "body": "<h5>Examples</h5>\n\n<pre><code>d4.chart('column', function columnChart() {\n    var chart = d4.baseChart({\n      axes: [{\n        key: 'x',\n        scale: 'ordinal'\n      }, {\n        key: 'y',\n        scale: 'linear'\n      }]\n    }, columnChartBuilder);\n    return chart;\n});\n</code></pre>"
            },
            "returns": "a reference to the chart object"
        },
        {
            "params": [
                {
                    "types": [
                        "Function"
                    ],
                    "name": "funct",
                    "description": "- function which returns a builder object."
                }
            ],
            "name": "builder",
            "type": "method",
            "fileName": "../src/base.js",
            "description": {
                "full": "<p>Specifies an object, which d4 uses to initialize the chart with. By default<br />d4 expects charts to return a builder object, which will be used to<br />configure defaults for the chart. Typically this means determining the<br />the default value for the various axes. This accessor allows you to<br />override the existing builder provided by a chart and use your own.</p>\n\n<h5>Examples</h5>\n\n<pre><code>myChart.builder = function(chart, data){\n    return {\n       link: function(chart, data) {\n           configureScales.bind(this)(chart, data);\n       }\n    };\n};\n</code></pre>",
                "summary": "<p>Specifies an object, which d4 uses to initialize the chart with. By default<br />d4 expects charts to return a builder object, which will be used to<br />configure defaults for the chart. Typically this means determining the<br />the default value for the various axes. This accessor allows you to<br />override the existing builder provided by a chart and use your own.</p>",
                "body": "<h5>Examples</h5>\n\n<pre><code>myChart.builder = function(chart, data){\n    return {\n       link: function(chart, data) {\n           configureScales.bind(this)(chart, data);\n       }\n    };\n};\n</code></pre>"
            }
        },
        {
            "params": [],
            "name": "features",
            "type": "method",
            "fileName": "../src/base.js",
            "description": {
                "full": "<p>To see what features are currently mixed into your chart you can use<br />this method. This function cannot be chained.</p>\n\n<h5>Examples</h5>\n\n<pre><code> // Mixout the yAxis which is provided as a default\n var chart = d4.charts.column()\n .mixout('yAxis');\n\n // Now test that the feature has been removed.\n console.log(chart.features());\n =&gt; [\"bars\", \"barLabels\", \"xAxis\"]\n</code></pre>",
                "summary": "<p>To see what features are currently mixed into your chart you can use<br />this method. This function cannot be chained.</p>",
                "body": "<h5>Examples</h5>\n\n<pre><code> // Mixout the yAxis which is provided as a default\n var chart = d4.charts.column()\n .mixout('yAxis');\n\n // Now test that the feature has been removed.\n console.log(chart.features());\n =&gt; [\"bars\", \"barLabels\", \"xAxis\"]\n</code></pre>"
            }
        },
        {
            "params": [
                {
                    "types": [
                        "Object"
                    ],
                    "name": "feature",
                    "description": "- an object describing the feature to mix in."
                },
                {
                    "types": [
                        "Integer"
                    ],
                    "name": "index",
                    "description": "- an optional number to specify the insertion layer."
                }
            ],
            "name": "mixin",
            "type": "method",
            "fileName": "../src/base.js",
            "description": {
                "full": "<p>Specifies a feature to be mixed into a given chart.<br />The feature is an object where the key represents the feature name, and a<br />value which is a function that when invoked returns a d4 feature object.</p>\n\n<h5>Examples</h5>\n\n<pre><code> // Mix in a feature at a specific depth\n chart.mixin({ 'grid': d4.features.grid }, 0)\n\n chart.mixin({ 'zeroLine': d4.features.referenceLine })\n</code></pre>",
                "summary": "<p>Specifies a feature to be mixed into a given chart.<br />The feature is an object where the key represents the feature name, and a<br />value which is a function that when invoked returns a d4 feature object.</p>",
                "body": "<h5>Examples</h5>\n\n<pre><code> // Mix in a feature at a specific depth\n chart.mixin({ 'grid': d4.features.grid }, 0)\n\n chart.mixin({ 'zeroLine': d4.features.referenceLine })\n</code></pre>"
            }
        },
        {
            "params": [
                {
                    "types": [
                        "String"
                    ],
                    "name": "name",
                    "description": "- accessor name for chart feature."
                }
            ],
            "name": "mixout",
            "type": "method",
            "fileName": "../src/base.js",
            "description": {
                "full": "<p>Specifies an existing feature of a chart to be removed (mixed out).</p>\n\n<h5>Examples</h5>\n\n<pre><code> // Mixout the yAxis which is provided as a default\n var chart = d4.charts.column()\n .mixout('yAxis');\n\n // Now test that the feature has been removed.\n console.log(chart.features());\n =&gt; [\"bars\", \"barLabels\", \"xAxis\"]\n</code></pre>",
                "summary": "<p>Specifies an existing feature of a chart to be removed (mixed out).</p>",
                "body": "<h5>Examples</h5>\n\n<pre><code> // Mixout the yAxis which is provided as a default\n var chart = d4.charts.column()\n .mixout('yAxis');\n\n // Now test that the feature has been removed.\n console.log(chart.features());\n =&gt; [\"bars\", \"barLabels\", \"xAxis\"]\n</code></pre>"
            }
        },
        {
            "params": [
                {
                    "types": [
                        "Function"
                    ],
                    "name": "funct",
                    "description": "- function which will perform the modifcation."
                }
            ],
            "name": "axes",
            "type": "method",
            "fileName": "../src/base.js",
            "description": {
                "full": "<p>This function returns the internal axes object as a parameter to the<br />supplied function.</p>",
                "summary": "<p>This function returns the internal axes object as a parameter to the<br />supplied function.</p>",
                "body": ""
            }
        },
        {
            "params": [
                {
                    "types": [
                        "String"
                    ],
                    "name": "name",
                    "description": "- accessor name for chart feature."
                },
                {
                    "types": [
                        "Function"
                    ],
                    "name": "funct",
                    "description": "- function which will perform the modifcation."
                }
            ],
            "name": "using",
            "type": "method",
            "fileName": "../src/base.js",
            "description": {
                "full": "<p>The heart of the d4 API is the <code>using</code> function, which allows you to<br />contextually modify attributes of the chart or one of its features.</p>\n\n<h5>Examples</h5>\n\n<pre><code> chart.mixin({ 'zeroLine': d4.features.referenceLine })\n .using('zeroLine', function(zero) {\n   zero\n     .x1(function() {\n       return this.x(0);\n     })\n });\n</code></pre>",
                "summary": "<p>The heart of the d4 API is the <code>using</code> function, which allows you to<br />contextually modify attributes of the chart or one of its features.</p>",
                "body": "<h5>Examples</h5>\n\n<pre><code> chart.mixin({ 'zeroLine': d4.features.referenceLine })\n .using('zeroLine', function(zero) {\n   zero\n     .x1(function() {\n       return this.x(0);\n     })\n });\n</code></pre>"
            }
        },
        {
            "params": [
                {
                    "types": [
                        "Varies"
                    ],
                    "name": "funct",
                    "description": "- An function or other variable to be wrapped in a function"
                }
            ],
            "name": "functor",
            "type": "method",
            "fileName": "../src/base.js",
            "description": {
                "full": "<p>Based on D3's own functor function.</p>\n\n<blockquote>\n  <p>If the specified value is a function, returns the specified value. Otherwise,<br />returns a function that returns the specified value. This method is used<br />internally as a lazy way of upcasting constant values to functions, in<br />cases where a property may be specified either as a function or a constant.<br />For example, many D3 layouts allow properties to be specified this way,<br />and it simplifies the implementation if we automatically convert constant<br />values to functions.</p>\n</blockquote>",
                "summary": "<p>Based on D3's own functor function.</p>\n\n<blockquote>\n  <p>If the specified value is a function, returns the specified value. Otherwise,<br />returns a function that returns the specified value. This method is used<br />internally as a lazy way of upcasting constant values to functions, in<br />cases where a property may be specified either as a function or a constant.<br />For example, many D3 layouts allow properties to be specified this way,<br />and it simplifies the implementation if we automatically convert constant<br />values to functions.</p>\n</blockquote>",
                "body": ""
            }
        },
        {},
        {
            "params": [
                {
                    "types": [
                        "Object"
                    ],
                    "name": "d4",
                    "description": "chart object"
                },
                {
                    "types": [
                        "Array"
                    ],
                    "name": "data",
                    "description": "array"
                },
                {
                    "types": [
                        "string"
                    ],
                    "name": "string",
                    "description": "represnting a dimension e.g. `x`,`y`."
                }
            ],
            "name": "",
            "type": "",
            "fileName": "../src/builders/scales.js",
            "description": {
                "full": "<p>Creates a linear scale for a dimension of a given chart.</p>",
                "summary": "<p>Creates a linear scale for a dimension of a given chart.</p>",
                "body": ""
            },
            "returns": "{Object} Chart scale object"
        },
        {
            "params": [
                {
                    "types": [
                        "Object"
                    ],
                    "name": "d4",
                    "description": "chart object"
                },
                {
                    "types": [
                        "Array"
                    ],
                    "name": "data",
                    "description": "array"
                },
                {
                    "types": [
                        "string"
                    ],
                    "name": "string",
                    "description": "represnting a dimension e.g. `x`,`y`."
                }
            ],
            "name": "",
            "type": "",
            "fileName": "../src/builders/scales.js",
            "description": {
                "full": "<p>Creates an ordinal scale for a dimension of a given chart.</p>",
                "summary": "<p>Creates an ordinal scale for a dimension of a given chart.</p>",
                "body": ""
            },
            "returns": "{Object} Chart scale object"
        },
        {},
        {
            "params": [],
            "name": "",
            "type": "",
            "fileName": "../src/charts/column.js",
            "description": {
                "full": "<p>The column chart has two axes (<code>x</code> and <code>y</code>). By default the column chart expects<br />   linear values for the <code>y</code> and ordinal values on the <code>x</code>. The basic column chart<br />   has four default features:</p>\n\n<p><strong>bars</strong> - series bars<br /><strong>barLabels</strong> - data labels above the bars<br /><strong>xAxis</strong> - the axis for the x dimension<br /><strong>yAxis</strong> - the axis for the y dimension</p>\n\n<h5>Example Usage</h5>\n\n<pre><code>var data = [\n    { x: '2010', y:-10 },\n    { x: '2011', y:20 },\n    { x: '2012', y:30 },\n    { x: '2013', y:40 },\n    { x: '2014', y:50 },\n  ];\nvar chart = d4.charts.column();\nd3.select('#example')\n.datum(data)\n.call(chart);\n</code></pre>\n\n<p>By default d4 expects a series object, which uses the following format: <code>{ x : '2010', y : 10 }</code>.<br />The default format may not be desired and so we'll override it:</p>\n\n<pre><code>var data = [\n  ['2010', -10],\n  ['2011', 20],\n  ['2012', 30],\n  ['2013', 40],\n  ['2014', 50]\n];\nvar chart = d4.charts.column()\n.x.$key(0)\n.y.$key(1);\n\nd3.select('#example')\n.datum(data)\n.call(chart);\n</code></pre>",
                "summary": "<p>The column chart has two axes (<code>x</code> and <code>y</code>). By default the column chart expects<br />   linear values for the <code>y</code> and ordinal values on the <code>x</code>. The basic column chart<br />   has four default features:</p>",
                "body": "<p><strong>bars</strong> - series bars<br /><strong>barLabels</strong> - data labels above the bars<br /><strong>xAxis</strong> - the axis for the x dimension<br /><strong>yAxis</strong> - the axis for the y dimension</p>\n\n<h5>Example Usage</h5>\n\n<pre><code>var data = [\n    { x: '2010', y:-10 },\n    { x: '2011', y:20 },\n    { x: '2012', y:30 },\n    { x: '2013', y:40 },\n    { x: '2014', y:50 },\n  ];\nvar chart = d4.charts.column();\nd3.select('#example')\n.datum(data)\n.call(chart);\n</code></pre>\n\n<p>By default d4 expects a series object, which uses the following format: <code>{ x : '2010', y : 10 }</code>.<br />The default format may not be desired and so we'll override it:</p>\n\n<pre><code>var data = [\n  ['2010', -10],\n  ['2011', 20],\n  ['2012', 30],\n  ['2013', 40],\n  ['2014', 50]\n];\nvar chart = d4.charts.column()\n.x.$key(0)\n.y.$key(1);\n\nd3.select('#example')\n.datum(data)\n.call(chart);\n</code></pre>"
            }
        },
        {},
        {
            "params": [],
            "name": "",
            "type": "",
            "fileName": "../src/charts/grouped-column.js",
            "description": {
                "full": "<p>The grouped column chart is used to compare a series of data elements grouped<br />along the xAxis. This chart is often useful in conjunction with a stacked column<br />chart because they can use the same data series, and where the stacked column highlights<br />the sum of the data series across an axis the grouped column can be used to show the<br />relative distribution.</p>\n\n<p><strong>bars</strong> - series bars<br /><strong>barLabels</strong> - data labels above the bars<br /><strong>groupsOf</strong> - an integer representing the number of columns in each group<br /><strong>xAxis</strong> - the axis for the x dimension<br /><strong>yAxis</strong> - the axis for the y dimension</p>\n\n<h5>Example Usage</h5>\n\n<pre><code>var data = [\n  { year: '2010', unitsSold:-100, salesman : 'Bob' },\n  { year: '2011', unitsSold:200, salesman : 'Bob' },\n  { year: '2012', unitsSold:300, salesman : 'Bob' },\n  { year: '2013', unitsSold:400, salesman : 'Bob' },\n  { year: '2014', unitsSold:500, salesman : 'Bob' },\n  { year: '2010', unitsSold:100, salesman : 'Gina' },\n  { year: '2011', unitsSold:100, salesman : 'Gina' },\n  { year: '2012', unitsSold:-100, salesman : 'Gina' },\n  { year: '2013', unitsSold:500, salesman : 'Gina' },\n  { year: '2014', unitsSold:600, salesman : 'Gina' },\n  { year: '2010', unitsSold:400, salesman : 'Average' },\n  { year: '2011', unitsSold:0, salesman : 'Average' },\n  { year: '2012', unitsSold:400, salesman : 'Average' },\n  { year: '2013', unitsSold:400, salesman : 'Average' },\n  { year: '2014', unitsSold:400, salesman : 'Average' }\n];\n\nvar parsedData = d4.parsers.nestedGroup()\n  .x('year')\n  .y('unitsSold')\n  .value('unitsSold')(data);\n\nvar chart = d4.charts.groupedColumn()\n.width($('#example').width())\n.x.$key('year')\n.y.$key('unitsSold')\n.groupsOf(parsedData.data[0].values.length);\n\nd3.select('#example')\n.datum(parsedData.data)\n.call(chart);\n</code></pre>",
                "summary": "<p>The grouped column chart is used to compare a series of data elements grouped<br />along the xAxis. This chart is often useful in conjunction with a stacked column<br />chart because they can use the same data series, and where the stacked column highlights<br />the sum of the data series across an axis the grouped column can be used to show the<br />relative distribution.</p>",
                "body": "<p><strong>bars</strong> - series bars<br /><strong>barLabels</strong> - data labels above the bars<br /><strong>groupsOf</strong> - an integer representing the number of columns in each group<br /><strong>xAxis</strong> - the axis for the x dimension<br /><strong>yAxis</strong> - the axis for the y dimension</p>\n\n<h5>Example Usage</h5>\n\n<pre><code>var data = [\n  { year: '2010', unitsSold:-100, salesman : 'Bob' },\n  { year: '2011', unitsSold:200, salesman : 'Bob' },\n  { year: '2012', unitsSold:300, salesman : 'Bob' },\n  { year: '2013', unitsSold:400, salesman : 'Bob' },\n  { year: '2014', unitsSold:500, salesman : 'Bob' },\n  { year: '2010', unitsSold:100, salesman : 'Gina' },\n  { year: '2011', unitsSold:100, salesman : 'Gina' },\n  { year: '2012', unitsSold:-100, salesman : 'Gina' },\n  { year: '2013', unitsSold:500, salesman : 'Gina' },\n  { year: '2014', unitsSold:600, salesman : 'Gina' },\n  { year: '2010', unitsSold:400, salesman : 'Average' },\n  { year: '2011', unitsSold:0, salesman : 'Average' },\n  { year: '2012', unitsSold:400, salesman : 'Average' },\n  { year: '2013', unitsSold:400, salesman : 'Average' },\n  { year: '2014', unitsSold:400, salesman : 'Average' }\n];\n\nvar parsedData = d4.parsers.nestedGroup()\n  .x('year')\n  .y('unitsSold')\n  .value('unitsSold')(data);\n\nvar chart = d4.charts.groupedColumn()\n.width($('#example').width())\n.x.$key('year')\n.y.$key('unitsSold')\n.groupsOf(parsedData.data[0].values.length);\n\nd3.select('#example')\n.datum(parsedData.data)\n.call(chart);\n</code></pre>"
            }
        },
        {},
        {
            "params": [],
            "name": "",
            "type": "",
            "fileName": "../src/charts/line.js",
            "description": {
                "full": "<p>The line series chart is used to compare a series of data elements grouped<br />  along the xAxis.</p>\n\n<p><strong>lineSeries</strong> - series lines<br /><strong>lineSeriesLabels</strong> - data labels beside the lines<br /><strong>xAxis</strong> - the axis for the x dimension<br /><strong>yAxis</strong> - the axis for the y dimension</p>\n\n<h5>Example Usage</h5>\n\n<pre><code>var data = [\n  { year: '2010', unitsSold:-100, salesman : 'Bob' },\n  { year: '2011', unitsSold:200, salesman : 'Bob' },\n  { year: '2012', unitsSold:300, salesman : 'Bob' },\n  { year: '2013', unitsSold:400, salesman : 'Bob' },\n  { year: '2014', unitsSold:500, salesman : 'Bob' },\n  { year: '2010', unitsSold:100, salesman : 'Gina' },\n  { year: '2011', unitsSold:100, salesman : 'Gina' },\n  { year: '2012', unitsSold:-100, salesman : 'Gina' },\n  { year: '2013', unitsSold:500, salesman : 'Gina' },\n  { year: '2014', unitsSold:600, salesman : 'Gina' },\n  { year: '2010', unitsSold:400, salesman : 'Average' },\n  { year: '2011', unitsSold:0, salesman : 'Average' },\n  { year: '2012', unitsSold:400, salesman : 'Average' },\n  { year: '2013', unitsSold:400, salesman : 'Average' },\n  { year: '2014', unitsSold:400, salesman : 'Average' }\n];\nvar parsedData = d4.parsers.nestedGroup()\n  .x(function(){\n    return 'year';\n  })\n  .nestKey(function(){\n    return 'salesman';\n  })\n  .y(function(){\n    return 'unitsSold';\n  })\n  .value(function(){\n    return 'unitsSold';\n  })(data);\n\nvar chart = d4.charts.line()\n.width($('#example').width())\n.x.$key('year')\n.y.$key('unitsSold');\n\nd3.select('#example')\n.datum(parsedData.data)\n.call(chart);\n</code></pre>",
                "summary": "<p>The line series chart is used to compare a series of data elements grouped<br />  along the xAxis.</p>",
                "body": "<p><strong>lineSeries</strong> - series lines<br /><strong>lineSeriesLabels</strong> - data labels beside the lines<br /><strong>xAxis</strong> - the axis for the x dimension<br /><strong>yAxis</strong> - the axis for the y dimension</p>\n\n<h5>Example Usage</h5>\n\n<pre><code>var data = [\n  { year: '2010', unitsSold:-100, salesman : 'Bob' },\n  { year: '2011', unitsSold:200, salesman : 'Bob' },\n  { year: '2012', unitsSold:300, salesman : 'Bob' },\n  { year: '2013', unitsSold:400, salesman : 'Bob' },\n  { year: '2014', unitsSold:500, salesman : 'Bob' },\n  { year: '2010', unitsSold:100, salesman : 'Gina' },\n  { year: '2011', unitsSold:100, salesman : 'Gina' },\n  { year: '2012', unitsSold:-100, salesman : 'Gina' },\n  { year: '2013', unitsSold:500, salesman : 'Gina' },\n  { year: '2014', unitsSold:600, salesman : 'Gina' },\n  { year: '2010', unitsSold:400, salesman : 'Average' },\n  { year: '2011', unitsSold:0, salesman : 'Average' },\n  { year: '2012', unitsSold:400, salesman : 'Average' },\n  { year: '2013', unitsSold:400, salesman : 'Average' },\n  { year: '2014', unitsSold:400, salesman : 'Average' }\n];\nvar parsedData = d4.parsers.nestedGroup()\n  .x(function(){\n    return 'year';\n  })\n  .nestKey(function(){\n    return 'salesman';\n  })\n  .y(function(){\n    return 'unitsSold';\n  })\n  .value(function(){\n    return 'unitsSold';\n  })(data);\n\nvar chart = d4.charts.line()\n.width($('#example').width())\n.x.$key('year')\n.y.$key('unitsSold');\n\nd3.select('#example')\n.datum(parsedData.data)\n.call(chart);\n</code></pre>"
            }
        },
        {},
        {
            "params": [],
            "name": "",
            "type": "",
            "fileName": "../src/charts/row.js",
            "description": {
                "full": "<p>The row chart has two axes (<code>x</code> and <code>y</code>). By default the column chart expects<br />   linear scale values for the <code>x</code> and ordinal scale values on the <code>y</code>. The basic column chart<br />   has four default features:</p>\n\n<p><strong>bars</strong> - series bars<br /><strong>rowLabels</strong> - data labels to the right of the bars<br /><strong>xAxis</strong> - the axis for the x dimension<br /><strong>yAxis</strong> - the axis for the y dimension</p>\n\n<h5>Example Usage</h5>\n\n<pre><code>var data = [\n      { y: '2010', x:-10 },\n      { y: '2011', x:20 },\n      { y: '2012', x:30 },\n      { y: '2013', x:40 },\n      { y: '2014', x:50 },\n    ];\n  var chart = d4.charts.row();\n  d3.select('#example')\n  .datum(data)\n  .call(chart);\n</code></pre>",
                "summary": "<p>The row chart has two axes (<code>x</code> and <code>y</code>). By default the column chart expects<br />   linear scale values for the <code>x</code> and ordinal scale values on the <code>y</code>. The basic column chart<br />   has four default features:</p>",
                "body": "<p><strong>bars</strong> - series bars<br /><strong>rowLabels</strong> - data labels to the right of the bars<br /><strong>xAxis</strong> - the axis for the x dimension<br /><strong>yAxis</strong> - the axis for the y dimension</p>\n\n<h5>Example Usage</h5>\n\n<pre><code>var data = [\n      { y: '2010', x:-10 },\n      { y: '2011', x:20 },\n      { y: '2012', x:30 },\n      { y: '2013', x:40 },\n      { y: '2014', x:50 },\n    ];\n  var chart = d4.charts.row();\n  d3.select('#example')\n  .datum(data)\n  .call(chart);\n</code></pre>"
            }
        },
        {},
        {},
        {},
        {},
        {},
        {},
        {},
        {},
        {},
        {},
        {},
        {},
        {},
        {},
        {},
        {},
        {},
        {},
        {},
        {
            "params": [],
            "name": "",
            "type": "",
            "fileName": "../src/features/waterfall-connectors.js",
            "description": {
                "full": "<p>Waterfall connectors are orthogonal series connectors which visually join<br />column series together by spanning the top or bottom of adjacent columns.</p>\n\n<p>When using this feature in charts other than waterfall, be aware that the<br />mixin expects an accessor property for <code>orientation</code>, which it uses to render<br />the direction of the lines.</p>\n\n<h5>Accessors</h5>\n\n<p><code>x</code> - Used in placement of the connector lines.<br /><code>y</code> - Used in placement of the connector lines.<br /><code>span</code> - calculates the length of the connector line<br /><code>classes</code> - applies the class to the connector lines.</p>",
                "summary": "<p>Waterfall connectors are orthogonal series connectors which visually join<br />column series together by spanning the top or bottom of adjacent columns.</p>",
                "body": "<p>When using this feature in charts other than waterfall, be aware that the<br />mixin expects an accessor property for <code>orientation</code>, which it uses to render<br />the direction of the lines.</p>\n\n<h5>Accessors</h5>\n\n<p><code>x</code> - Used in placement of the connector lines.<br /><code>y</code> - Used in placement of the connector lines.<br /><code>span</code> - calculates the length of the connector line<br /><code>classes</code> - applies the class to the connector lines.</p>"
            }
        },
        {},
        {},
        {},
        {},
        {
            "params": [],
            "name": "",
            "type": "",
            "fileName": "../src/parsers/nested-group.js",
            "description": {
                "full": "<p>The nested group parser is useful for grouped column charts where multiple<br />data items need to appear relative to the axis value, for example grouped<br />column charts or multi-series line charts.</p>\n\n<pre><code>_____________________\n|           _        |\n|   _ _    | |_      |\n|  | | |   | | |     |\n----------------------\n</code></pre>\n\n<p>This module makes use of the d3's \"nest\" data structure layout</p>\n\n<p><a href='https://github.com/mbostock/d3/wiki/Arrays#-nest'>https://github.com/mbostock/d3/wiki/Arrays#-nest</a></p>\n\n<h4>Approach</h4>\n\n<p>Just like D3, this parser uses a chaining declaritiave style to build up<br />the necessary prerequistes to create the waterfall data. Here is a simple<br />example. Given a data item structure like this: {\"category\" : \"Category One\", \"value\" : 23 }</p>\n\n<pre><code>var parser = d4.parsers.nestedGroup()\n    .x('category')\n    .y('value')\n    .value('value');\n\nvar groupedColumnData = parser(data);\n</code></pre>\n\n<p>Keep reading for more information on these various accessor functions.</p>\n\n<h4>Accessor Methods</h4>\n\n<p><code>x</code> - A function which returns a key to access the x values in the data array<br /><code>y</code> - A function which returns a key to access the y values in the data array<br /><code>value</code> - A function which returns a key to access the values in the data array.<br /><code>data</code> - An array of objects with their dimensions specified like this:</p>\n\n<pre><code>var data = [\n{\"year\" : \"2010\", \"category\" : \"Category One\", \"value\" : 23 },\n{\"year\" : \"2010\", \"category\" : \"Category Two\", \"value\" : 55 },\n{\"year\" : \"2010\", \"category\" : \"Category Three\", \"value\" : -10 },\n{\"year\" : \"2010\", \"category\" : \"Category Four\", \"value\" : 5 }]\n</code></pre>",
                "summary": "<p>The nested group parser is useful for grouped column charts where multiple<br />data items need to appear relative to the axis value, for example grouped<br />column charts or multi-series line charts.</p>",
                "body": "<pre><code>_____________________\n|           _        |\n|   _ _    | |_      |\n|  | | |   | | |     |\n----------------------\n</code></pre>\n\n<p>This module makes use of the d3's \"nest\" data structure layout</p>\n\n<p><a href='https://github.com/mbostock/d3/wiki/Arrays#-nest'>https://github.com/mbostock/d3/wiki/Arrays#-nest</a></p>\n\n<h4>Approach</h4>\n\n<p>Just like D3, this parser uses a chaining declaritiave style to build up<br />the necessary prerequistes to create the waterfall data. Here is a simple<br />example. Given a data item structure like this: {\"category\" : \"Category One\", \"value\" : 23 }</p>\n\n<pre><code>var parser = d4.parsers.nestedGroup()\n    .x('category')\n    .y('value')\n    .value('value');\n\nvar groupedColumnData = parser(data);\n</code></pre>\n\n<p>Keep reading for more information on these various accessor functions.</p>\n\n<h4>Accessor Methods</h4>\n\n<p><code>x</code> - A function which returns a key to access the x values in the data array<br /><code>y</code> - A function which returns a key to access the y values in the data array<br /><code>value</code> - A function which returns a key to access the values in the data array.<br /><code>data</code> - An array of objects with their dimensions specified like this:</p>\n\n<pre><code>var data = [\n{\"year\" : \"2010\", \"category\" : \"Category One\", \"value\" : 23 },\n{\"year\" : \"2010\", \"category\" : \"Category Two\", \"value\" : 55 },\n{\"year\" : \"2010\", \"category\" : \"Category Three\", \"value\" : -10 },\n{\"year\" : \"2010\", \"category\" : \"Category Four\", \"value\" : 5 }]\n</code></pre>"
            }
        },
        {},
        {},
        {
            "params": [],
            "name": "",
            "type": "",
            "fileName": "../src/parsers/nested-stack.js",
            "description": {
                "full": "<p>The nested stack parser is useful for charts which take a data series<br />  and wants to sort them across a dimension and then display the results.<br />  The most common usecase would be a stacked column chart like this:</p>\n\n<pre><code>_____________________\n|    _               |\n|   | |   _          |\n|   |-|  | |   _     |\n|   |-|  |-|  |-|    |\n|   | |  |-|  |-|    |\n----------------------\n</code></pre>\n\n<p>This module makes use of the d3's \"nest\" data structure, and \"stack\" layout</p>\n\n<p><a href='https://github.com/mbostock/d3/wiki/Arrays#-nest'>https://github.com/mbostock/d3/wiki/Arrays#-nest</a><br /><a href='https://github.com/mbostock/d3/wiki/Stack-Layout'>https://github.com/mbostock/d3/wiki/Stack-Layout</a></p>\n\n<h4>Approach</h4>\n\n<p>Just like D3, this parser uses a chaining declaritiave style to build up<br />the necessary prerequistes to create the stacked data. Here is a simple<br />example:</p>\n\n<pre><code>    var parser = d4.parsers.nestedStack()\n        .x(function() {\n          return 'title';\n        })\n        .y(function(){\n          return 'group';\n        })\n        .value(function() {\n          return 'values';\n        });\n\n    var stackedData = parser(data);\n</code></pre>\n\n<p>Keep reading for more information on these various accessor functions.</p>\n\n<h5>Benefits</h5>\n\n<ul>\n<li>Supports negative and positive stacked data series.</li>\n</ul>\n\n<h5>Limitations</h5>\n\n<ul>\n<li>The parser expects the stack will occur on the yAxis, which means it is only suitable for column charts presently.</li>\n</ul>\n\n<h5>Accessor Methods</h5>\n\n<p><code>x</code> : - function which returns a key to access the x values in the data array<br /><code>y</code> : - function which returns a key to access the y values in the data array<br /><code>value</code> : - function which returns a key to access the values in the data array.<br /><code>data</code> : array - An array of objects with their dimensions specified like this:</p>\n\n<pre><code>var data = [{ \"title\": \"3 Years\", \"group\" : \"one\", \"value\": 30 },\n            { \"title\": \"3 Years\", \"group\" : \"two\", \"value\": 20 },\n            { \"title\": \"3 Years\", \"group\" : \"three\", \"value\": 10 },\n            { \"title\": \"5 Years\", \"group\" : \"one\",  \"value\": 3 },\n            { \"title\": \"5 Years\", \"group\" : \"two\", \"value\": 2 },\n            { \"title\": \"5 Years\", \"group\" : \"three\", \"value\": 1 }]\n</code></pre>\n\n<h5>Example Usage</h5>\n\n<p>Given the example data and dimension variables above you can use this module<br />in the following way:</p>\n\n<pre><code>var parser = d4.parsers.nestedStack()\n.x(function() {\n  return 'title';\n})\n.y(function(){\n  return 'group';\n})\n.value(function() {\n  return 'value';\n})\n.call(data);\n</code></pre>\n\n<p>The <code>parser</code> variable will now be an object containing the following structure:</p>\n\n<pre><code>{\n  data: Array\n  value: {\n    key: string,\n    values: Array\n  },\n  x: {\n    key: string,\n    values: Array\n  },\n  y: {\n    key: string,\n    values: Array\n  }\n}\n</code></pre>",
                "summary": "<p>The nested stack parser is useful for charts which take a data series<br />  and wants to sort them across a dimension and then display the results.<br />  The most common usecase would be a stacked column chart like this:</p>",
                "body": "<pre><code>_____________________\n|    _               |\n|   | |   _          |\n|   |-|  | |   _     |\n|   |-|  |-|  |-|    |\n|   | |  |-|  |-|    |\n----------------------\n</code></pre>\n\n<p>This module makes use of the d3's \"nest\" data structure, and \"stack\" layout</p>\n\n<p><a href='https://github.com/mbostock/d3/wiki/Arrays#-nest'>https://github.com/mbostock/d3/wiki/Arrays#-nest</a><br /><a href='https://github.com/mbostock/d3/wiki/Stack-Layout'>https://github.com/mbostock/d3/wiki/Stack-Layout</a></p>\n\n<h4>Approach</h4>\n\n<p>Just like D3, this parser uses a chaining declaritiave style to build up<br />the necessary prerequistes to create the stacked data. Here is a simple<br />example:</p>\n\n<pre><code>    var parser = d4.parsers.nestedStack()\n        .x(function() {\n          return 'title';\n        })\n        .y(function(){\n          return 'group';\n        })\n        .value(function() {\n          return 'values';\n        });\n\n    var stackedData = parser(data);\n</code></pre>\n\n<p>Keep reading for more information on these various accessor functions.</p>\n\n<h5>Benefits</h5>\n\n<ul>\n<li>Supports negative and positive stacked data series.</li>\n</ul>\n\n<h5>Limitations</h5>\n\n<ul>\n<li>The parser expects the stack will occur on the yAxis, which means it is only suitable for column charts presently.</li>\n</ul>\n\n<h5>Accessor Methods</h5>\n\n<p><code>x</code> : - function which returns a key to access the x values in the data array<br /><code>y</code> : - function which returns a key to access the y values in the data array<br /><code>value</code> : - function which returns a key to access the values in the data array.<br /><code>data</code> : array - An array of objects with their dimensions specified like this:</p>\n\n<pre><code>var data = [{ \"title\": \"3 Years\", \"group\" : \"one\", \"value\": 30 },\n            { \"title\": \"3 Years\", \"group\" : \"two\", \"value\": 20 },\n            { \"title\": \"3 Years\", \"group\" : \"three\", \"value\": 10 },\n            { \"title\": \"5 Years\", \"group\" : \"one\",  \"value\": 3 },\n            { \"title\": \"5 Years\", \"group\" : \"two\", \"value\": 2 },\n            { \"title\": \"5 Years\", \"group\" : \"three\", \"value\": 1 }]\n</code></pre>\n\n<h5>Example Usage</h5>\n\n<p>Given the example data and dimension variables above you can use this module<br />in the following way:</p>\n\n<pre><code>var parser = d4.parsers.nestedStack()\n.x(function() {\n  return 'title';\n})\n.y(function(){\n  return 'group';\n})\n.value(function() {\n  return 'value';\n})\n.call(data);\n</code></pre>\n\n<p>The <code>parser</code> variable will now be an object containing the following structure:</p>\n\n<pre><code>{\n  data: Array\n  value: {\n    key: string,\n    values: Array\n  },\n  x: {\n    key: string,\n    values: Array\n  },\n  y: {\n    key: string,\n    values: Array\n  }\n}\n</code></pre>"
            }
        },
        {},
        {},
        {
            "params": [],
            "name": "",
            "type": "",
            "fileName": "../src/parsers/waterfall.js",
            "description": {
                "full": "<p>The waterfall parser is useful for waterfall charts where data items need to account<br />    for the position of earlier values:</p>\n\n<pre><code>_____________________\n|   _        _______ |\n|  |_|___   | |  | | |\n|      |_|__|_|  | | |\n|                |_| |\n----------------------\n\nThis module makes use of the d3's \"nest\" data structure, and \"stack\" layout\n<a href='https://github.com/mbostock/d3/wiki/Arrays#-nest'>https://github.com/mbostock/d3/wiki/Arrays#-nest</a>\n<a href='https://github.com/mbostock/d3/wiki/Stack-Layout'>https://github.com/mbostock/d3/wiki/Stack-Layout</a>\n\n\nApproach:\nJust like D3, this parser uses a chaining declaritiave style to build up\nthe necessary prerequistes to create the waterfall data. Here is a simple\nexample. Given a data item structure like this: {\"category\" : \"Category One\", \"value\" : 23 }\n\nvar parser = d4.parsers.waterfall()\n    .x(function() {\n      return 'category';\n    })\n    .y(function(){\n      return 'value';\n    })\n    .value(function() {\n      return 'value';\n    });\n\nvar waterfallData = parser(data);\n\nKeep reading for more information on these various accessor functions.\n\nBenefits:\n</code></pre>\n\n<p>Supports horizontal or vertical waterfalls<br />Supports totaling series using a special \"e\" value in a data item.</p>\n\n<pre><code>Limitations:\n</code></pre>\n\n<p>Does not support stacked waterfalls.</p>\n\n<pre><code>Accessor Methods:\n</code></pre>\n\n<p>x : - function which returns a key to access the x values in the data array<br />y : - function which returns a key to access the y values in the data array<br />value : - function which returns a key to access the values in the data array.<br />data : array - An array of objects with their dimensions specified<br />      like this:</p>\n\n<pre><code>  var data = [\n  {\"category\" : \"Category One\", \"value\" : 23 },\n  {\"category\" : \"Category Two\", \"value\" : 55 },\n  {\"category\" : \"Category Three\", \"value\" : -10 },\n  {\"category\" : \"Category Four\", \"value\" : 5 },\n  {\"category\" : \"Category Five\", \"value\" : \"e\" }]\n\nSPECIAL NOTE:\nWaterfalls charts typically have the ability to display subtotals at any point.\nIn order to use this feature simply set the value of your subtotal column to \"e.\"\n\nExample Usage:\nGiven the example data and dimension variables above you can use this module\nin the following way:\n\nvar parser = d4.parsers.nestedStack()\n.dimensions(dimensions)\n.call(data);\n\nThe `parser` variable will now be an object containing the following structure:\n{\n  data: Array\n  value: {\n    key: string,\n    values: Array\n  },\n  x: {\n    key: string,\n    values: Array\n  },\n  y: {\n    key: string,\n    values: Array\n  }\n}\n\nTaking these attributes one-by-one:\n</code></pre>\n\n<p>data - is an array of items stacked by D3<br />value - an object with a key representing the value accessor and an array of values<br />x - an object with a key representing the x accessor and an array of values<br />y - an object with a key representing the y accessor and an array of values</p>",
                "summary": "<p>The waterfall parser is useful for waterfall charts where data items need to account<br />    for the position of earlier values:</p>",
                "body": "<pre><code>_____________________\n|   _        _______ |\n|  |_|___   | |  | | |\n|      |_|__|_|  | | |\n|                |_| |\n----------------------\n\nThis module makes use of the d3's \"nest\" data structure, and \"stack\" layout\n<a href='https://github.com/mbostock/d3/wiki/Arrays#-nest'>https://github.com/mbostock/d3/wiki/Arrays#-nest</a>\n<a href='https://github.com/mbostock/d3/wiki/Stack-Layout'>https://github.com/mbostock/d3/wiki/Stack-Layout</a>\n\n\nApproach:\nJust like D3, this parser uses a chaining declaritiave style to build up\nthe necessary prerequistes to create the waterfall data. Here is a simple\nexample. Given a data item structure like this: {\"category\" : \"Category One\", \"value\" : 23 }\n\nvar parser = d4.parsers.waterfall()\n    .x(function() {\n      return 'category';\n    })\n    .y(function(){\n      return 'value';\n    })\n    .value(function() {\n      return 'value';\n    });\n\nvar waterfallData = parser(data);\n\nKeep reading for more information on these various accessor functions.\n\nBenefits:\n</code></pre>\n\n<p>Supports horizontal or vertical waterfalls<br />Supports totaling series using a special \"e\" value in a data item.</p>\n\n<pre><code>Limitations:\n</code></pre>\n\n<p>Does not support stacked waterfalls.</p>\n\n<pre><code>Accessor Methods:\n</code></pre>\n\n<p>x : - function which returns a key to access the x values in the data array<br />y : - function which returns a key to access the y values in the data array<br />value : - function which returns a key to access the values in the data array.<br />data : array - An array of objects with their dimensions specified<br />      like this:</p>\n\n<pre><code>  var data = [\n  {\"category\" : \"Category One\", \"value\" : 23 },\n  {\"category\" : \"Category Two\", \"value\" : 55 },\n  {\"category\" : \"Category Three\", \"value\" : -10 },\n  {\"category\" : \"Category Four\", \"value\" : 5 },\n  {\"category\" : \"Category Five\", \"value\" : \"e\" }]\n\nSPECIAL NOTE:\nWaterfalls charts typically have the ability to display subtotals at any point.\nIn order to use this feature simply set the value of your subtotal column to \"e.\"\n\nExample Usage:\nGiven the example data and dimension variables above you can use this module\nin the following way:\n\nvar parser = d4.parsers.nestedStack()\n.dimensions(dimensions)\n.call(data);\n\nThe `parser` variable will now be an object containing the following structure:\n{\n  data: Array\n  value: {\n    key: string,\n    values: Array\n  },\n  x: {\n    key: string,\n    values: Array\n  },\n  y: {\n    key: string,\n    values: Array\n  }\n}\n\nTaking these attributes one-by-one:\n</code></pre>\n\n<p>data - is an array of items stacked by D3<br />value - an object with a key representing the value accessor and an array of values<br />x - an object with a key representing the x accessor and an array of values<br />y - an object with a key representing the y accessor and an array of values</p>"
            }
        }
    ],
    "categories": [],
    "files": [
        {
            "tag": "../src/base.js",
            "moxComments": [
                {
                    "params": [
                        {
                            "types": [
                                "String"
                            ],
                            "name": "name",
                            "description": "- accessor name for chart."
                        },
                        {
                            "types": [
                                "Function"
                            ],
                            "name": "funct",
                            "description": "- function which will instantiate the chart."
                        }
                    ],
                    "name": "chart",
                    "type": "method",
                    "fileName": "../src/base.js",
                    "description": {
                        "full": "<p>This function allows you to register a reusable chart with d4.</p>",
                        "summary": "<p>This function allows you to register a reusable chart with d4.</p>",
                        "body": ""
                    },
                    "returns": "a reference to the chart function"
                },
                {
                    "params": [
                        {
                            "types": [
                                "String"
                            ],
                            "name": "name",
                            "description": "- accessor name for chart feature."
                        },
                        {
                            "types": [
                                "Function"
                            ],
                            "name": "funct",
                            "description": "- function which will instantiate the chart feature."
                        }
                    ],
                    "name": "feature",
                    "type": "method",
                    "fileName": "../src/base.js",
                    "description": {
                        "full": "<p>This function allows you to register a reusable chart feature with d4.</p>",
                        "summary": "<p>This function allows you to register a reusable chart feature with d4.</p>",
                        "body": ""
                    },
                    "returns": "a reference to the chart feature"
                },
                {
                    "params": [
                        {
                            "types": [
                                "String"
                            ],
                            "name": "name",
                            "description": "- accessor name for chart builder."
                        },
                        {
                            "types": [
                                "Function"
                            ],
                            "name": "funct",
                            "description": "- function which will instantiate the chart builder."
                        }
                    ],
                    "name": "builder",
                    "type": "method",
                    "fileName": "../src/base.js",
                    "description": {
                        "full": "<p>This function allows you to register a reusable chart builder with d4.</p>",
                        "summary": "<p>This function allows you to register a reusable chart builder with d4.</p>",
                        "body": ""
                    },
                    "returns": "a reference to the chart builder"
                },
                {
                    "params": [
                        {
                            "types": [
                                "String"
                            ],
                            "name": "name",
                            "description": "- accessor name for data parser."
                        },
                        {
                            "types": [
                                "Function"
                            ],
                            "name": "funct",
                            "description": "- function which will instantiate the data parser."
                        }
                    ],
                    "name": "parser",
                    "type": "method",
                    "fileName": "../src/base.js",
                    "description": {
                        "full": "<p>This function allows you to register a reusable data parser with d4.</p>",
                        "summary": "<p>This function allows you to register a reusable data parser with d4.</p>",
                        "body": ""
                    },
                    "returns": "a reference to the data parser"
                },
                {
                    "params": [
                        {
                            "types": [
                                "Function"
                            ],
                            "name": "defaultBuilder",
                            "description": "- function which will return a valid builder object when invoked."
                        },
                        {
                            "types": [
                                "Object"
                            ],
                            "name": "config",
                            "description": "- an object representing chart configuration settings"
                        }
                    ],
                    "name": "baseChart",
                    "type": "method",
                    "fileName": "../src/base.js",
                    "description": {
                        "full": "<p>This function creates a d4 chart object. It is only used when creating a<br />new chart factory.</p>\n\n<h5>Examples</h5>\n\n<pre><code>d4.chart('column', function columnChart() {\n    var chart = d4.baseChart({\n      axes: [{\n        key: 'x',\n        scale: 'ordinal'\n      }, {\n        key: 'y',\n        scale: 'linear'\n      }]\n    }, columnChartBuilder);\n    return chart;\n});\n</code></pre>",
                        "summary": "<p>This function creates a d4 chart object. It is only used when creating a<br />new chart factory.</p>",
                        "body": "<h5>Examples</h5>\n\n<pre><code>d4.chart('column', function columnChart() {\n    var chart = d4.baseChart({\n      axes: [{\n        key: 'x',\n        scale: 'ordinal'\n      }, {\n        key: 'y',\n        scale: 'linear'\n      }]\n    }, columnChartBuilder);\n    return chart;\n});\n</code></pre>"
                    },
                    "returns": "a reference to the chart object"
                },
                {
                    "params": [
                        {
                            "types": [
                                "Function"
                            ],
                            "name": "funct",
                            "description": "- function which returns a builder object."
                        }
                    ],
                    "name": "builder",
                    "type": "method",
                    "fileName": "../src/base.js",
                    "description": {
                        "full": "<p>Specifies an object, which d4 uses to initialize the chart with. By default<br />d4 expects charts to return a builder object, which will be used to<br />configure defaults for the chart. Typically this means determining the<br />the default value for the various axes. This accessor allows you to<br />override the existing builder provided by a chart and use your own.</p>\n\n<h5>Examples</h5>\n\n<pre><code>myChart.builder = function(chart, data){\n    return {\n       link: function(chart, data) {\n           configureScales.bind(this)(chart, data);\n       }\n    };\n};\n</code></pre>",
                        "summary": "<p>Specifies an object, which d4 uses to initialize the chart with. By default<br />d4 expects charts to return a builder object, which will be used to<br />configure defaults for the chart. Typically this means determining the<br />the default value for the various axes. This accessor allows you to<br />override the existing builder provided by a chart and use your own.</p>",
                        "body": "<h5>Examples</h5>\n\n<pre><code>myChart.builder = function(chart, data){\n    return {\n       link: function(chart, data) {\n           configureScales.bind(this)(chart, data);\n       }\n    };\n};\n</code></pre>"
                    }
                },
                {
                    "params": [],
                    "name": "features",
                    "type": "method",
                    "fileName": "../src/base.js",
                    "description": {
                        "full": "<p>To see what features are currently mixed into your chart you can use<br />this method. This function cannot be chained.</p>\n\n<h5>Examples</h5>\n\n<pre><code> // Mixout the yAxis which is provided as a default\n var chart = d4.charts.column()\n .mixout('yAxis');\n\n // Now test that the feature has been removed.\n console.log(chart.features());\n =&gt; [\"bars\", \"barLabels\", \"xAxis\"]\n</code></pre>",
                        "summary": "<p>To see what features are currently mixed into your chart you can use<br />this method. This function cannot be chained.</p>",
                        "body": "<h5>Examples</h5>\n\n<pre><code> // Mixout the yAxis which is provided as a default\n var chart = d4.charts.column()\n .mixout('yAxis');\n\n // Now test that the feature has been removed.\n console.log(chart.features());\n =&gt; [\"bars\", \"barLabels\", \"xAxis\"]\n</code></pre>"
                    }
                },
                {
                    "params": [
                        {
                            "types": [
                                "Object"
                            ],
                            "name": "feature",
                            "description": "- an object describing the feature to mix in."
                        },
                        {
                            "types": [
                                "Integer"
                            ],
                            "name": "index",
                            "description": "- an optional number to specify the insertion layer."
                        }
                    ],
                    "name": "mixin",
                    "type": "method",
                    "fileName": "../src/base.js",
                    "description": {
                        "full": "<p>Specifies a feature to be mixed into a given chart.<br />The feature is an object where the key represents the feature name, and a<br />value which is a function that when invoked returns a d4 feature object.</p>\n\n<h5>Examples</h5>\n\n<pre><code> // Mix in a feature at a specific depth\n chart.mixin({ 'grid': d4.features.grid }, 0)\n\n chart.mixin({ 'zeroLine': d4.features.referenceLine })\n</code></pre>",
                        "summary": "<p>Specifies a feature to be mixed into a given chart.<br />The feature is an object where the key represents the feature name, and a<br />value which is a function that when invoked returns a d4 feature object.</p>",
                        "body": "<h5>Examples</h5>\n\n<pre><code> // Mix in a feature at a specific depth\n chart.mixin({ 'grid': d4.features.grid }, 0)\n\n chart.mixin({ 'zeroLine': d4.features.referenceLine })\n</code></pre>"
                    }
                },
                {
                    "params": [
                        {
                            "types": [
                                "String"
                            ],
                            "name": "name",
                            "description": "- accessor name for chart feature."
                        }
                    ],
                    "name": "mixout",
                    "type": "method",
                    "fileName": "../src/base.js",
                    "description": {
                        "full": "<p>Specifies an existing feature of a chart to be removed (mixed out).</p>\n\n<h5>Examples</h5>\n\n<pre><code> // Mixout the yAxis which is provided as a default\n var chart = d4.charts.column()\n .mixout('yAxis');\n\n // Now test that the feature has been removed.\n console.log(chart.features());\n =&gt; [\"bars\", \"barLabels\", \"xAxis\"]\n</code></pre>",
                        "summary": "<p>Specifies an existing feature of a chart to be removed (mixed out).</p>",
                        "body": "<h5>Examples</h5>\n\n<pre><code> // Mixout the yAxis which is provided as a default\n var chart = d4.charts.column()\n .mixout('yAxis');\n\n // Now test that the feature has been removed.\n console.log(chart.features());\n =&gt; [\"bars\", \"barLabels\", \"xAxis\"]\n</code></pre>"
                    }
                },
                {
                    "params": [
                        {
                            "types": [
                                "Function"
                            ],
                            "name": "funct",
                            "description": "- function which will perform the modifcation."
                        }
                    ],
                    "name": "axes",
                    "type": "method",
                    "fileName": "../src/base.js",
                    "description": {
                        "full": "<p>This function returns the internal axes object as a parameter to the<br />supplied function.</p>",
                        "summary": "<p>This function returns the internal axes object as a parameter to the<br />supplied function.</p>",
                        "body": ""
                    }
                },
                {
                    "params": [
                        {
                            "types": [
                                "String"
                            ],
                            "name": "name",
                            "description": "- accessor name for chart feature."
                        },
                        {
                            "types": [
                                "Function"
                            ],
                            "name": "funct",
                            "description": "- function which will perform the modifcation."
                        }
                    ],
                    "name": "using",
                    "type": "method",
                    "fileName": "../src/base.js",
                    "description": {
                        "full": "<p>The heart of the d4 API is the <code>using</code> function, which allows you to<br />contextually modify attributes of the chart or one of its features.</p>\n\n<h5>Examples</h5>\n\n<pre><code> chart.mixin({ 'zeroLine': d4.features.referenceLine })\n .using('zeroLine', function(zero) {\n   zero\n     .x1(function() {\n       return this.x(0);\n     })\n });\n</code></pre>",
                        "summary": "<p>The heart of the d4 API is the <code>using</code> function, which allows you to<br />contextually modify attributes of the chart or one of its features.</p>",
                        "body": "<h5>Examples</h5>\n\n<pre><code> chart.mixin({ 'zeroLine': d4.features.referenceLine })\n .using('zeroLine', function(zero) {\n   zero\n     .x1(function() {\n       return this.x(0);\n     })\n });\n</code></pre>"
                    }
                },
                {
                    "params": [
                        {
                            "types": [
                                "Varies"
                            ],
                            "name": "funct",
                            "description": "- An function or other variable to be wrapped in a function"
                        }
                    ],
                    "name": "functor",
                    "type": "method",
                    "fileName": "../src/base.js",
                    "description": {
                        "full": "<p>Based on D3's own functor function.</p>\n\n<blockquote>\n  <p>If the specified value is a function, returns the specified value. Otherwise,<br />returns a function that returns the specified value. This method is used<br />internally as a lazy way of upcasting constant values to functions, in<br />cases where a property may be specified either as a function or a constant.<br />For example, many D3 layouts allow properties to be specified this way,<br />and it simplifies the implementation if we automatically convert constant<br />values to functions.</p>\n</blockquote>",
                        "summary": "<p>Based on D3's own functor function.</p>\n\n<blockquote>\n  <p>If the specified value is a function, returns the specified value. Otherwise,<br />returns a function that returns the specified value. This method is used<br />internally as a lazy way of upcasting constant values to functions, in<br />cases where a property may be specified either as a function or a constant.<br />For example, many D3 layouts allow properties to be specified this way,<br />and it simplifies the implementation if we automatically convert constant<br />values to functions.</p>\n</blockquote>",
                        "body": ""
                    }
                }
            ]
        },
        {
            "tag": "../src/builders/scales.js",
            "moxComments": [
                {
                    "params": [
                        {
                            "types": [
                                "Object"
                            ],
                            "name": "d4",
                            "description": "chart object"
                        },
                        {
                            "types": [
                                "Array"
                            ],
                            "name": "data",
                            "description": "array"
                        },
                        {
                            "types": [
                                "string"
                            ],
                            "name": "string",
                            "description": "represnting a dimension e.g. `x`,`y`."
                        }
                    ],
                    "name": "",
                    "type": "",
                    "fileName": "../src/builders/scales.js",
                    "description": {
                        "full": "<p>Creates a linear scale for a dimension of a given chart.</p>",
                        "summary": "<p>Creates a linear scale for a dimension of a given chart.</p>",
                        "body": ""
                    },
                    "returns": "{Object} Chart scale object"
                },
                {
                    "params": [
                        {
                            "types": [
                                "Object"
                            ],
                            "name": "d4",
                            "description": "chart object"
                        },
                        {
                            "types": [
                                "Array"
                            ],
                            "name": "data",
                            "description": "array"
                        },
                        {
                            "types": [
                                "string"
                            ],
                            "name": "string",
                            "description": "represnting a dimension e.g. `x`,`y`."
                        }
                    ],
                    "name": "",
                    "type": "",
                    "fileName": "../src/builders/scales.js",
                    "description": {
                        "full": "<p>Creates an ordinal scale for a dimension of a given chart.</p>",
                        "summary": "<p>Creates an ordinal scale for a dimension of a given chart.</p>",
                        "body": ""
                    },
                    "returns": "{Object} Chart scale object"
                }
            ]
        },
        {
            "tag": "../src/charts/column.js",
            "moxComments": [
                {
                    "params": [],
                    "name": "",
                    "type": "",
                    "fileName": "../src/charts/column.js",
                    "description": {
                        "full": "<p>The column chart has two axes (<code>x</code> and <code>y</code>). By default the column chart expects<br />   linear values for the <code>y</code> and ordinal values on the <code>x</code>. The basic column chart<br />   has four default features:</p>\n\n<p><strong>bars</strong> - series bars<br /><strong>barLabels</strong> - data labels above the bars<br /><strong>xAxis</strong> - the axis for the x dimension<br /><strong>yAxis</strong> - the axis for the y dimension</p>\n\n<h5>Example Usage</h5>\n\n<pre><code>var data = [\n    { x: '2010', y:-10 },\n    { x: '2011', y:20 },\n    { x: '2012', y:30 },\n    { x: '2013', y:40 },\n    { x: '2014', y:50 },\n  ];\nvar chart = d4.charts.column();\nd3.select('#example')\n.datum(data)\n.call(chart);\n</code></pre>\n\n<p>By default d4 expects a series object, which uses the following format: <code>{ x : '2010', y : 10 }</code>.<br />The default format may not be desired and so we'll override it:</p>\n\n<pre><code>var data = [\n  ['2010', -10],\n  ['2011', 20],\n  ['2012', 30],\n  ['2013', 40],\n  ['2014', 50]\n];\nvar chart = d4.charts.column()\n.x.$key(0)\n.y.$key(1);\n\nd3.select('#example')\n.datum(data)\n.call(chart);\n</code></pre>",
                        "summary": "<p>The column chart has two axes (<code>x</code> and <code>y</code>). By default the column chart expects<br />   linear values for the <code>y</code> and ordinal values on the <code>x</code>. The basic column chart<br />   has four default features:</p>",
                        "body": "<p><strong>bars</strong> - series bars<br /><strong>barLabels</strong> - data labels above the bars<br /><strong>xAxis</strong> - the axis for the x dimension<br /><strong>yAxis</strong> - the axis for the y dimension</p>\n\n<h5>Example Usage</h5>\n\n<pre><code>var data = [\n    { x: '2010', y:-10 },\n    { x: '2011', y:20 },\n    { x: '2012', y:30 },\n    { x: '2013', y:40 },\n    { x: '2014', y:50 },\n  ];\nvar chart = d4.charts.column();\nd3.select('#example')\n.datum(data)\n.call(chart);\n</code></pre>\n\n<p>By default d4 expects a series object, which uses the following format: <code>{ x : '2010', y : 10 }</code>.<br />The default format may not be desired and so we'll override it:</p>\n\n<pre><code>var data = [\n  ['2010', -10],\n  ['2011', 20],\n  ['2012', 30],\n  ['2013', 40],\n  ['2014', 50]\n];\nvar chart = d4.charts.column()\n.x.$key(0)\n.y.$key(1);\n\nd3.select('#example')\n.datum(data)\n.call(chart);\n</code></pre>"
                    }
                }
            ]
        },
        {
            "tag": "../src/charts/grouped-column.js",
            "moxComments": [
                {
                    "params": [],
                    "name": "",
                    "type": "",
                    "fileName": "../src/charts/grouped-column.js",
                    "description": {
                        "full": "<p>The grouped column chart is used to compare a series of data elements grouped<br />along the xAxis. This chart is often useful in conjunction with a stacked column<br />chart because they can use the same data series, and where the stacked column highlights<br />the sum of the data series across an axis the grouped column can be used to show the<br />relative distribution.</p>\n\n<p><strong>bars</strong> - series bars<br /><strong>barLabels</strong> - data labels above the bars<br /><strong>groupsOf</strong> - an integer representing the number of columns in each group<br /><strong>xAxis</strong> - the axis for the x dimension<br /><strong>yAxis</strong> - the axis for the y dimension</p>\n\n<h5>Example Usage</h5>\n\n<pre><code>var data = [\n  { year: '2010', unitsSold:-100, salesman : 'Bob' },\n  { year: '2011', unitsSold:200, salesman : 'Bob' },\n  { year: '2012', unitsSold:300, salesman : 'Bob' },\n  { year: '2013', unitsSold:400, salesman : 'Bob' },\n  { year: '2014', unitsSold:500, salesman : 'Bob' },\n  { year: '2010', unitsSold:100, salesman : 'Gina' },\n  { year: '2011', unitsSold:100, salesman : 'Gina' },\n  { year: '2012', unitsSold:-100, salesman : 'Gina' },\n  { year: '2013', unitsSold:500, salesman : 'Gina' },\n  { year: '2014', unitsSold:600, salesman : 'Gina' },\n  { year: '2010', unitsSold:400, salesman : 'Average' },\n  { year: '2011', unitsSold:0, salesman : 'Average' },\n  { year: '2012', unitsSold:400, salesman : 'Average' },\n  { year: '2013', unitsSold:400, salesman : 'Average' },\n  { year: '2014', unitsSold:400, salesman : 'Average' }\n];\n\nvar parsedData = d4.parsers.nestedGroup()\n  .x('year')\n  .y('unitsSold')\n  .value('unitsSold')(data);\n\nvar chart = d4.charts.groupedColumn()\n.width($('#example').width())\n.x.$key('year')\n.y.$key('unitsSold')\n.groupsOf(parsedData.data[0].values.length);\n\nd3.select('#example')\n.datum(parsedData.data)\n.call(chart);\n</code></pre>",
                        "summary": "<p>The grouped column chart is used to compare a series of data elements grouped<br />along the xAxis. This chart is often useful in conjunction with a stacked column<br />chart because they can use the same data series, and where the stacked column highlights<br />the sum of the data series across an axis the grouped column can be used to show the<br />relative distribution.</p>",
                        "body": "<p><strong>bars</strong> - series bars<br /><strong>barLabels</strong> - data labels above the bars<br /><strong>groupsOf</strong> - an integer representing the number of columns in each group<br /><strong>xAxis</strong> - the axis for the x dimension<br /><strong>yAxis</strong> - the axis for the y dimension</p>\n\n<h5>Example Usage</h5>\n\n<pre><code>var data = [\n  { year: '2010', unitsSold:-100, salesman : 'Bob' },\n  { year: '2011', unitsSold:200, salesman : 'Bob' },\n  { year: '2012', unitsSold:300, salesman : 'Bob' },\n  { year: '2013', unitsSold:400, salesman : 'Bob' },\n  { year: '2014', unitsSold:500, salesman : 'Bob' },\n  { year: '2010', unitsSold:100, salesman : 'Gina' },\n  { year: '2011', unitsSold:100, salesman : 'Gina' },\n  { year: '2012', unitsSold:-100, salesman : 'Gina' },\n  { year: '2013', unitsSold:500, salesman : 'Gina' },\n  { year: '2014', unitsSold:600, salesman : 'Gina' },\n  { year: '2010', unitsSold:400, salesman : 'Average' },\n  { year: '2011', unitsSold:0, salesman : 'Average' },\n  { year: '2012', unitsSold:400, salesman : 'Average' },\n  { year: '2013', unitsSold:400, salesman : 'Average' },\n  { year: '2014', unitsSold:400, salesman : 'Average' }\n];\n\nvar parsedData = d4.parsers.nestedGroup()\n  .x('year')\n  .y('unitsSold')\n  .value('unitsSold')(data);\n\nvar chart = d4.charts.groupedColumn()\n.width($('#example').width())\n.x.$key('year')\n.y.$key('unitsSold')\n.groupsOf(parsedData.data[0].values.length);\n\nd3.select('#example')\n.datum(parsedData.data)\n.call(chart);\n</code></pre>"
                    }
                }
            ]
        },
        {
            "tag": "../src/charts/line.js",
            "moxComments": [
                {
                    "params": [],
                    "name": "",
                    "type": "",
                    "fileName": "../src/charts/line.js",
                    "description": {
                        "full": "<p>The line series chart is used to compare a series of data elements grouped<br />  along the xAxis.</p>\n\n<p><strong>lineSeries</strong> - series lines<br /><strong>lineSeriesLabels</strong> - data labels beside the lines<br /><strong>xAxis</strong> - the axis for the x dimension<br /><strong>yAxis</strong> - the axis for the y dimension</p>\n\n<h5>Example Usage</h5>\n\n<pre><code>var data = [\n  { year: '2010', unitsSold:-100, salesman : 'Bob' },\n  { year: '2011', unitsSold:200, salesman : 'Bob' },\n  { year: '2012', unitsSold:300, salesman : 'Bob' },\n  { year: '2013', unitsSold:400, salesman : 'Bob' },\n  { year: '2014', unitsSold:500, salesman : 'Bob' },\n  { year: '2010', unitsSold:100, salesman : 'Gina' },\n  { year: '2011', unitsSold:100, salesman : 'Gina' },\n  { year: '2012', unitsSold:-100, salesman : 'Gina' },\n  { year: '2013', unitsSold:500, salesman : 'Gina' },\n  { year: '2014', unitsSold:600, salesman : 'Gina' },\n  { year: '2010', unitsSold:400, salesman : 'Average' },\n  { year: '2011', unitsSold:0, salesman : 'Average' },\n  { year: '2012', unitsSold:400, salesman : 'Average' },\n  { year: '2013', unitsSold:400, salesman : 'Average' },\n  { year: '2014', unitsSold:400, salesman : 'Average' }\n];\nvar parsedData = d4.parsers.nestedGroup()\n  .x(function(){\n    return 'year';\n  })\n  .nestKey(function(){\n    return 'salesman';\n  })\n  .y(function(){\n    return 'unitsSold';\n  })\n  .value(function(){\n    return 'unitsSold';\n  })(data);\n\nvar chart = d4.charts.line()\n.width($('#example').width())\n.x.$key('year')\n.y.$key('unitsSold');\n\nd3.select('#example')\n.datum(parsedData.data)\n.call(chart);\n</code></pre>",
                        "summary": "<p>The line series chart is used to compare a series of data elements grouped<br />  along the xAxis.</p>",
                        "body": "<p><strong>lineSeries</strong> - series lines<br /><strong>lineSeriesLabels</strong> - data labels beside the lines<br /><strong>xAxis</strong> - the axis for the x dimension<br /><strong>yAxis</strong> - the axis for the y dimension</p>\n\n<h5>Example Usage</h5>\n\n<pre><code>var data = [\n  { year: '2010', unitsSold:-100, salesman : 'Bob' },\n  { year: '2011', unitsSold:200, salesman : 'Bob' },\n  { year: '2012', unitsSold:300, salesman : 'Bob' },\n  { year: '2013', unitsSold:400, salesman : 'Bob' },\n  { year: '2014', unitsSold:500, salesman : 'Bob' },\n  { year: '2010', unitsSold:100, salesman : 'Gina' },\n  { year: '2011', unitsSold:100, salesman : 'Gina' },\n  { year: '2012', unitsSold:-100, salesman : 'Gina' },\n  { year: '2013', unitsSold:500, salesman : 'Gina' },\n  { year: '2014', unitsSold:600, salesman : 'Gina' },\n  { year: '2010', unitsSold:400, salesman : 'Average' },\n  { year: '2011', unitsSold:0, salesman : 'Average' },\n  { year: '2012', unitsSold:400, salesman : 'Average' },\n  { year: '2013', unitsSold:400, salesman : 'Average' },\n  { year: '2014', unitsSold:400, salesman : 'Average' }\n];\nvar parsedData = d4.parsers.nestedGroup()\n  .x(function(){\n    return 'year';\n  })\n  .nestKey(function(){\n    return 'salesman';\n  })\n  .y(function(){\n    return 'unitsSold';\n  })\n  .value(function(){\n    return 'unitsSold';\n  })(data);\n\nvar chart = d4.charts.line()\n.width($('#example').width())\n.x.$key('year')\n.y.$key('unitsSold');\n\nd3.select('#example')\n.datum(parsedData.data)\n.call(chart);\n</code></pre>"
                    }
                }
            ]
        },
        {
            "tag": "../src/charts/row.js",
            "moxComments": [
                {
                    "params": [],
                    "name": "",
                    "type": "",
                    "fileName": "../src/charts/row.js",
                    "description": {
                        "full": "<p>The row chart has two axes (<code>x</code> and <code>y</code>). By default the column chart expects<br />   linear scale values for the <code>x</code> and ordinal scale values on the <code>y</code>. The basic column chart<br />   has four default features:</p>\n\n<p><strong>bars</strong> - series bars<br /><strong>rowLabels</strong> - data labels to the right of the bars<br /><strong>xAxis</strong> - the axis for the x dimension<br /><strong>yAxis</strong> - the axis for the y dimension</p>\n\n<h5>Example Usage</h5>\n\n<pre><code>var data = [\n      { y: '2010', x:-10 },\n      { y: '2011', x:20 },\n      { y: '2012', x:30 },\n      { y: '2013', x:40 },\n      { y: '2014', x:50 },\n    ];\n  var chart = d4.charts.row();\n  d3.select('#example')\n  .datum(data)\n  .call(chart);\n</code></pre>",
                        "summary": "<p>The row chart has two axes (<code>x</code> and <code>y</code>). By default the column chart expects<br />   linear scale values for the <code>x</code> and ordinal scale values on the <code>y</code>. The basic column chart<br />   has four default features:</p>",
                        "body": "<p><strong>bars</strong> - series bars<br /><strong>rowLabels</strong> - data labels to the right of the bars<br /><strong>xAxis</strong> - the axis for the x dimension<br /><strong>yAxis</strong> - the axis for the y dimension</p>\n\n<h5>Example Usage</h5>\n\n<pre><code>var data = [\n      { y: '2010', x:-10 },\n      { y: '2011', x:20 },\n      { y: '2012', x:30 },\n      { y: '2013', x:40 },\n      { y: '2014', x:50 },\n    ];\n  var chart = d4.charts.row();\n  d3.select('#example')\n  .datum(data)\n  .call(chart);\n</code></pre>"
                    }
                }
            ]
        },
        {
            "tag": "../src/features/waterfall-connectors.js",
            "moxComments": [
                {
                    "params": [],
                    "name": "",
                    "type": "",
                    "fileName": "../src/features/waterfall-connectors.js",
                    "description": {
                        "full": "<p>Waterfall connectors are orthogonal series connectors which visually join<br />column series together by spanning the top or bottom of adjacent columns.</p>\n\n<p>When using this feature in charts other than waterfall, be aware that the<br />mixin expects an accessor property for <code>orientation</code>, which it uses to render<br />the direction of the lines.</p>\n\n<h5>Accessors</h5>\n\n<p><code>x</code> - Used in placement of the connector lines.<br /><code>y</code> - Used in placement of the connector lines.<br /><code>span</code> - calculates the length of the connector line<br /><code>classes</code> - applies the class to the connector lines.</p>",
                        "summary": "<p>Waterfall connectors are orthogonal series connectors which visually join<br />column series together by spanning the top or bottom of adjacent columns.</p>",
                        "body": "<p>When using this feature in charts other than waterfall, be aware that the<br />mixin expects an accessor property for <code>orientation</code>, which it uses to render<br />the direction of the lines.</p>\n\n<h5>Accessors</h5>\n\n<p><code>x</code> - Used in placement of the connector lines.<br /><code>y</code> - Used in placement of the connector lines.<br /><code>span</code> - calculates the length of the connector line<br /><code>classes</code> - applies the class to the connector lines.</p>"
                    }
                }
            ]
        },
        {
            "tag": "../src/parsers/nested-group.js",
            "moxComments": [
                {
                    "params": [],
                    "name": "",
                    "type": "",
                    "fileName": "../src/parsers/nested-group.js",
                    "description": {
                        "full": "<p>The nested group parser is useful for grouped column charts where multiple<br />data items need to appear relative to the axis value, for example grouped<br />column charts or multi-series line charts.</p>\n\n<pre><code>_____________________\n|           _        |\n|   _ _    | |_      |\n|  | | |   | | |     |\n----------------------\n</code></pre>\n\n<p>This module makes use of the d3's \"nest\" data structure layout</p>\n\n<p><a href='https://github.com/mbostock/d3/wiki/Arrays#-nest'>https://github.com/mbostock/d3/wiki/Arrays#-nest</a></p>\n\n<h4>Approach</h4>\n\n<p>Just like D3, this parser uses a chaining declaritiave style to build up<br />the necessary prerequistes to create the waterfall data. Here is a simple<br />example. Given a data item structure like this: {\"category\" : \"Category One\", \"value\" : 23 }</p>\n\n<pre><code>var parser = d4.parsers.nestedGroup()\n    .x('category')\n    .y('value')\n    .value('value');\n\nvar groupedColumnData = parser(data);\n</code></pre>\n\n<p>Keep reading for more information on these various accessor functions.</p>\n\n<h4>Accessor Methods</h4>\n\n<p><code>x</code> - A function which returns a key to access the x values in the data array<br /><code>y</code> - A function which returns a key to access the y values in the data array<br /><code>value</code> - A function which returns a key to access the values in the data array.<br /><code>data</code> - An array of objects with their dimensions specified like this:</p>\n\n<pre><code>var data = [\n{\"year\" : \"2010\", \"category\" : \"Category One\", \"value\" : 23 },\n{\"year\" : \"2010\", \"category\" : \"Category Two\", \"value\" : 55 },\n{\"year\" : \"2010\", \"category\" : \"Category Three\", \"value\" : -10 },\n{\"year\" : \"2010\", \"category\" : \"Category Four\", \"value\" : 5 }]\n</code></pre>",
                        "summary": "<p>The nested group parser is useful for grouped column charts where multiple<br />data items need to appear relative to the axis value, for example grouped<br />column charts or multi-series line charts.</p>",
                        "body": "<pre><code>_____________________\n|           _        |\n|   _ _    | |_      |\n|  | | |   | | |     |\n----------------------\n</code></pre>\n\n<p>This module makes use of the d3's \"nest\" data structure layout</p>\n\n<p><a href='https://github.com/mbostock/d3/wiki/Arrays#-nest'>https://github.com/mbostock/d3/wiki/Arrays#-nest</a></p>\n\n<h4>Approach</h4>\n\n<p>Just like D3, this parser uses a chaining declaritiave style to build up<br />the necessary prerequistes to create the waterfall data. Here is a simple<br />example. Given a data item structure like this: {\"category\" : \"Category One\", \"value\" : 23 }</p>\n\n<pre><code>var parser = d4.parsers.nestedGroup()\n    .x('category')\n    .y('value')\n    .value('value');\n\nvar groupedColumnData = parser(data);\n</code></pre>\n\n<p>Keep reading for more information on these various accessor functions.</p>\n\n<h4>Accessor Methods</h4>\n\n<p><code>x</code> - A function which returns a key to access the x values in the data array<br /><code>y</code> - A function which returns a key to access the y values in the data array<br /><code>value</code> - A function which returns a key to access the values in the data array.<br /><code>data</code> - An array of objects with their dimensions specified like this:</p>\n\n<pre><code>var data = [\n{\"year\" : \"2010\", \"category\" : \"Category One\", \"value\" : 23 },\n{\"year\" : \"2010\", \"category\" : \"Category Two\", \"value\" : 55 },\n{\"year\" : \"2010\", \"category\" : \"Category Three\", \"value\" : -10 },\n{\"year\" : \"2010\", \"category\" : \"Category Four\", \"value\" : 5 }]\n</code></pre>"
                    }
                }
            ]
        },
        {
            "tag": "../src/parsers/nested-stack.js",
            "moxComments": [
                {
                    "params": [],
                    "name": "",
                    "type": "",
                    "fileName": "../src/parsers/nested-stack.js",
                    "description": {
                        "full": "<p>The nested stack parser is useful for charts which take a data series<br />  and wants to sort them across a dimension and then display the results.<br />  The most common usecase would be a stacked column chart like this:</p>\n\n<pre><code>_____________________\n|    _               |\n|   | |   _          |\n|   |-|  | |   _     |\n|   |-|  |-|  |-|    |\n|   | |  |-|  |-|    |\n----------------------\n</code></pre>\n\n<p>This module makes use of the d3's \"nest\" data structure, and \"stack\" layout</p>\n\n<p><a href='https://github.com/mbostock/d3/wiki/Arrays#-nest'>https://github.com/mbostock/d3/wiki/Arrays#-nest</a><br /><a href='https://github.com/mbostock/d3/wiki/Stack-Layout'>https://github.com/mbostock/d3/wiki/Stack-Layout</a></p>\n\n<h4>Approach</h4>\n\n<p>Just like D3, this parser uses a chaining declaritiave style to build up<br />the necessary prerequistes to create the stacked data. Here is a simple<br />example:</p>\n\n<pre><code>    var parser = d4.parsers.nestedStack()\n        .x(function() {\n          return 'title';\n        })\n        .y(function(){\n          return 'group';\n        })\n        .value(function() {\n          return 'values';\n        });\n\n    var stackedData = parser(data);\n</code></pre>\n\n<p>Keep reading for more information on these various accessor functions.</p>\n\n<h5>Benefits</h5>\n\n<ul>\n<li>Supports negative and positive stacked data series.</li>\n</ul>\n\n<h5>Limitations</h5>\n\n<ul>\n<li>The parser expects the stack will occur on the yAxis, which means it is only suitable for column charts presently.</li>\n</ul>\n\n<h5>Accessor Methods</h5>\n\n<p><code>x</code> : - function which returns a key to access the x values in the data array<br /><code>y</code> : - function which returns a key to access the y values in the data array<br /><code>value</code> : - function which returns a key to access the values in the data array.<br /><code>data</code> : array - An array of objects with their dimensions specified like this:</p>\n\n<pre><code>var data = [{ \"title\": \"3 Years\", \"group\" : \"one\", \"value\": 30 },\n            { \"title\": \"3 Years\", \"group\" : \"two\", \"value\": 20 },\n            { \"title\": \"3 Years\", \"group\" : \"three\", \"value\": 10 },\n            { \"title\": \"5 Years\", \"group\" : \"one\",  \"value\": 3 },\n            { \"title\": \"5 Years\", \"group\" : \"two\", \"value\": 2 },\n            { \"title\": \"5 Years\", \"group\" : \"three\", \"value\": 1 }]\n</code></pre>\n\n<h5>Example Usage</h5>\n\n<p>Given the example data and dimension variables above you can use this module<br />in the following way:</p>\n\n<pre><code>var parser = d4.parsers.nestedStack()\n.x(function() {\n  return 'title';\n})\n.y(function(){\n  return 'group';\n})\n.value(function() {\n  return 'value';\n})\n.call(data);\n</code></pre>\n\n<p>The <code>parser</code> variable will now be an object containing the following structure:</p>\n\n<pre><code>{\n  data: Array\n  value: {\n    key: string,\n    values: Array\n  },\n  x: {\n    key: string,\n    values: Array\n  },\n  y: {\n    key: string,\n    values: Array\n  }\n}\n</code></pre>",
                        "summary": "<p>The nested stack parser is useful for charts which take a data series<br />  and wants to sort them across a dimension and then display the results.<br />  The most common usecase would be a stacked column chart like this:</p>",
                        "body": "<pre><code>_____________________\n|    _               |\n|   | |   _          |\n|   |-|  | |   _     |\n|   |-|  |-|  |-|    |\n|   | |  |-|  |-|    |\n----------------------\n</code></pre>\n\n<p>This module makes use of the d3's \"nest\" data structure, and \"stack\" layout</p>\n\n<p><a href='https://github.com/mbostock/d3/wiki/Arrays#-nest'>https://github.com/mbostock/d3/wiki/Arrays#-nest</a><br /><a href='https://github.com/mbostock/d3/wiki/Stack-Layout'>https://github.com/mbostock/d3/wiki/Stack-Layout</a></p>\n\n<h4>Approach</h4>\n\n<p>Just like D3, this parser uses a chaining declaritiave style to build up<br />the necessary prerequistes to create the stacked data. Here is a simple<br />example:</p>\n\n<pre><code>    var parser = d4.parsers.nestedStack()\n        .x(function() {\n          return 'title';\n        })\n        .y(function(){\n          return 'group';\n        })\n        .value(function() {\n          return 'values';\n        });\n\n    var stackedData = parser(data);\n</code></pre>\n\n<p>Keep reading for more information on these various accessor functions.</p>\n\n<h5>Benefits</h5>\n\n<ul>\n<li>Supports negative and positive stacked data series.</li>\n</ul>\n\n<h5>Limitations</h5>\n\n<ul>\n<li>The parser expects the stack will occur on the yAxis, which means it is only suitable for column charts presently.</li>\n</ul>\n\n<h5>Accessor Methods</h5>\n\n<p><code>x</code> : - function which returns a key to access the x values in the data array<br /><code>y</code> : - function which returns a key to access the y values in the data array<br /><code>value</code> : - function which returns a key to access the values in the data array.<br /><code>data</code> : array - An array of objects with their dimensions specified like this:</p>\n\n<pre><code>var data = [{ \"title\": \"3 Years\", \"group\" : \"one\", \"value\": 30 },\n            { \"title\": \"3 Years\", \"group\" : \"two\", \"value\": 20 },\n            { \"title\": \"3 Years\", \"group\" : \"three\", \"value\": 10 },\n            { \"title\": \"5 Years\", \"group\" : \"one\",  \"value\": 3 },\n            { \"title\": \"5 Years\", \"group\" : \"two\", \"value\": 2 },\n            { \"title\": \"5 Years\", \"group\" : \"three\", \"value\": 1 }]\n</code></pre>\n\n<h5>Example Usage</h5>\n\n<p>Given the example data and dimension variables above you can use this module<br />in the following way:</p>\n\n<pre><code>var parser = d4.parsers.nestedStack()\n.x(function() {\n  return 'title';\n})\n.y(function(){\n  return 'group';\n})\n.value(function() {\n  return 'value';\n})\n.call(data);\n</code></pre>\n\n<p>The <code>parser</code> variable will now be an object containing the following structure:</p>\n\n<pre><code>{\n  data: Array\n  value: {\n    key: string,\n    values: Array\n  },\n  x: {\n    key: string,\n    values: Array\n  },\n  y: {\n    key: string,\n    values: Array\n  }\n}\n</code></pre>"
                    }
                }
            ]
        },
        {
            "tag": "../src/parsers/waterfall.js",
            "moxComments": [
                {
                    "params": [],
                    "name": "",
                    "type": "",
                    "fileName": "../src/parsers/waterfall.js",
                    "description": {
                        "full": "<p>The waterfall parser is useful for waterfall charts where data items need to account<br />    for the position of earlier values:</p>\n\n<pre><code>_____________________\n|   _        _______ |\n|  |_|___   | |  | | |\n|      |_|__|_|  | | |\n|                |_| |\n----------------------\n\nThis module makes use of the d3's \"nest\" data structure, and \"stack\" layout\n<a href='https://github.com/mbostock/d3/wiki/Arrays#-nest'>https://github.com/mbostock/d3/wiki/Arrays#-nest</a>\n<a href='https://github.com/mbostock/d3/wiki/Stack-Layout'>https://github.com/mbostock/d3/wiki/Stack-Layout</a>\n\n\nApproach:\nJust like D3, this parser uses a chaining declaritiave style to build up\nthe necessary prerequistes to create the waterfall data. Here is a simple\nexample. Given a data item structure like this: {\"category\" : \"Category One\", \"value\" : 23 }\n\nvar parser = d4.parsers.waterfall()\n    .x(function() {\n      return 'category';\n    })\n    .y(function(){\n      return 'value';\n    })\n    .value(function() {\n      return 'value';\n    });\n\nvar waterfallData = parser(data);\n\nKeep reading for more information on these various accessor functions.\n\nBenefits:\n</code></pre>\n\n<p>Supports horizontal or vertical waterfalls<br />Supports totaling series using a special \"e\" value in a data item.</p>\n\n<pre><code>Limitations:\n</code></pre>\n\n<p>Does not support stacked waterfalls.</p>\n\n<pre><code>Accessor Methods:\n</code></pre>\n\n<p>x : - function which returns a key to access the x values in the data array<br />y : - function which returns a key to access the y values in the data array<br />value : - function which returns a key to access the values in the data array.<br />data : array - An array of objects with their dimensions specified<br />      like this:</p>\n\n<pre><code>  var data = [\n  {\"category\" : \"Category One\", \"value\" : 23 },\n  {\"category\" : \"Category Two\", \"value\" : 55 },\n  {\"category\" : \"Category Three\", \"value\" : -10 },\n  {\"category\" : \"Category Four\", \"value\" : 5 },\n  {\"category\" : \"Category Five\", \"value\" : \"e\" }]\n\nSPECIAL NOTE:\nWaterfalls charts typically have the ability to display subtotals at any point.\nIn order to use this feature simply set the value of your subtotal column to \"e.\"\n\nExample Usage:\nGiven the example data and dimension variables above you can use this module\nin the following way:\n\nvar parser = d4.parsers.nestedStack()\n.dimensions(dimensions)\n.call(data);\n\nThe `parser` variable will now be an object containing the following structure:\n{\n  data: Array\n  value: {\n    key: string,\n    values: Array\n  },\n  x: {\n    key: string,\n    values: Array\n  },\n  y: {\n    key: string,\n    values: Array\n  }\n}\n\nTaking these attributes one-by-one:\n</code></pre>\n\n<p>data - is an array of items stacked by D3<br />value - an object with a key representing the value accessor and an array of values<br />x - an object with a key representing the x accessor and an array of values<br />y - an object with a key representing the y accessor and an array of values</p>",
                        "summary": "<p>The waterfall parser is useful for waterfall charts where data items need to account<br />    for the position of earlier values:</p>",
                        "body": "<pre><code>_____________________\n|   _        _______ |\n|  |_|___   | |  | | |\n|      |_|__|_|  | | |\n|                |_| |\n----------------------\n\nThis module makes use of the d3's \"nest\" data structure, and \"stack\" layout\n<a href='https://github.com/mbostock/d3/wiki/Arrays#-nest'>https://github.com/mbostock/d3/wiki/Arrays#-nest</a>\n<a href='https://github.com/mbostock/d3/wiki/Stack-Layout'>https://github.com/mbostock/d3/wiki/Stack-Layout</a>\n\n\nApproach:\nJust like D3, this parser uses a chaining declaritiave style to build up\nthe necessary prerequistes to create the waterfall data. Here is a simple\nexample. Given a data item structure like this: {\"category\" : \"Category One\", \"value\" : 23 }\n\nvar parser = d4.parsers.waterfall()\n    .x(function() {\n      return 'category';\n    })\n    .y(function(){\n      return 'value';\n    })\n    .value(function() {\n      return 'value';\n    });\n\nvar waterfallData = parser(data);\n\nKeep reading for more information on these various accessor functions.\n\nBenefits:\n</code></pre>\n\n<p>Supports horizontal or vertical waterfalls<br />Supports totaling series using a special \"e\" value in a data item.</p>\n\n<pre><code>Limitations:\n</code></pre>\n\n<p>Does not support stacked waterfalls.</p>\n\n<pre><code>Accessor Methods:\n</code></pre>\n\n<p>x : - function which returns a key to access the x values in the data array<br />y : - function which returns a key to access the y values in the data array<br />value : - function which returns a key to access the values in the data array.<br />data : array - An array of objects with their dimensions specified<br />      like this:</p>\n\n<pre><code>  var data = [\n  {\"category\" : \"Category One\", \"value\" : 23 },\n  {\"category\" : \"Category Two\", \"value\" : 55 },\n  {\"category\" : \"Category Three\", \"value\" : -10 },\n  {\"category\" : \"Category Four\", \"value\" : 5 },\n  {\"category\" : \"Category Five\", \"value\" : \"e\" }]\n\nSPECIAL NOTE:\nWaterfalls charts typically have the ability to display subtotals at any point.\nIn order to use this feature simply set the value of your subtotal column to \"e.\"\n\nExample Usage:\nGiven the example data and dimension variables above you can use this module\nin the following way:\n\nvar parser = d4.parsers.nestedStack()\n.dimensions(dimensions)\n.call(data);\n\nThe `parser` variable will now be an object containing the following structure:\n{\n  data: Array\n  value: {\n    key: string,\n    values: Array\n  },\n  x: {\n    key: string,\n    values: Array\n  },\n  y: {\n    key: string,\n    values: Array\n  }\n}\n\nTaking these attributes one-by-one:\n</code></pre>\n\n<p>data - is an array of items stacked by D3<br />value - an object with a key representing the value accessor and an array of values<br />x - an object with a key representing the x accessor and an array of values<br />y - an object with a key representing the y accessor and an array of values</p>"
                    }
                }
            ]
        }
    ],
    "name": "d4",
    "version": "0.4.0"
}